name: VNC Data Static Timeout
on:
  workflow_dispatch:
    inputs:
      base64_config:
        description: 'Base64 encoded JSON configuration'
        required: true
        type: string

env:
  DISPLAY: :1
  VNC_PORT: 5901
  NOVNC_PORT: 6080

jobs:
  process:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Fetch and Parse Config
        id: config
        run: |
          CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)

          VNC_ENABLED=$(echo "$CONFIG" | jq -r '.vnc_enabled // "false"')
          CLOUDFLARE_ENABLED=$(echo "$CONFIG" | jq -r '.cloudflare_enabled // "false"')
          WEBSHARE_ENABLED=$(echo "$CONFIG" | jq -r '.webshare_enabled // "false"')
          echo "vnc_enabled=$VNC_ENABLED" >> $GITHUB_OUTPUT
          echo "cloudflare_enabled=$CLOUDFLARE_ENABLED" >> $GITHUB_OUTPUT
          echo "webshare_enabled=$WEBSHARE_ENABLED" >> $GITHUB_OUTPUT

          USER_ID=$(echo "$CONFIG" | jq -r '.user_id // "69c3090b-464d-4de3-9358-ceca1c9e2aa8"')
          WORKSPACE_ID=$(echo "$CONFIG" | jq -r '.workspace_id // "ceae1caa-1538-4859-8e1a-24a8b4904d5f"')
          echo "user_id=$USER_ID" >> $GITHUB_OUTPUT
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT

          if [ "$VNC_ENABLED" = "true" ]; then
            VNC_PASSWORD=$(echo "$CONFIG" | jq -r '.vnc_password // ""')
            echo "vnc_password=$VNC_PASSWORD" >> $GITHUB_OUTPUT
          fi

          if [ "$CLOUDFLARE_ENABLED" = "true" ]; then
            CLOUDFLARE_API_TOKEN=$(echo "$CONFIG" | jq -r '.cloudflare_api_token // ""')
            CLOUDFLARE_ACCOUNT_ID=$(echo "$CONFIG" | jq -r '.cloudflare_account_id // ""')
            CLOUDFLARE_ZONE_ID=$(echo "$CONFIG" | jq -r '.cloudflare_zone_id // ""')
            HOSTNAME=$(echo "$CONFIG" | jq -r '.hostname // ""')
            BROWSER_PROFILE_ID=$(echo "$CONFIG" | jq -r '.browser_profile_id // ""')
            echo "cloudflare_api_token=$CLOUDFLARE_API_TOKEN" >> $GITHUB_OUTPUT
            echo "cloudflare_account_id=$CLOUDFLARE_ACCOUNT_ID" >> $GITHUB_OUTPUT
            echo "cloudflare_zone_id=$CLOUDFLARE_ZONE_ID" >> $GITHUB_OUTPUT
            echo "hostname=$HOSTNAME" >> $GITHUB_OUTPUT
            echo "browser_profile_id=$BROWSER_PROFILE_ID" >> $GITHUB_OUTPUT
          fi

          if [ "$WEBSHARE_ENABLED" = "true" ]; then
            WEBSHARE_API_TOKEN=$(echo "$CONFIG" | jq -r '.webshare_api_token // ""')
            echo "webshare_api_token=$WEBSHARE_API_TOKEN" >> $GITHUB_OUTPUT
          fi

          echo "‚úÖ Config: VNC=$VNC_ENABLED | Cloudflare=$CLOUDFLARE_ENABLED | Webshare=$WEBSHARE_ENABLED"

      - name: Register IP with Webshare
        if: steps.config.outputs.webshare_enabled == 'true'
        id: webshare
        run: |
          PUBLIC_IP=$(curl -s 'https://api.ipify.org?format=json' | jq -r '.ip')
          RESPONSE=$(curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/" \
            -X POST -d "{\"ip_address\": \"$PUBLIC_IP\"}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}")
          AUTH_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
          [ -n "$AUTH_ID" ] && echo "webshare_auth_id=$AUTH_ID" >> $GITHUB_OUTPUT && echo "‚úÖ IP registered (Auth ID: $AUTH_ID)" || echo "‚ö†Ô∏è Webshare registration failed"

      - name: Install Desktop Environment
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            xfce4 xfce4-goodies xfce4-terminal firefox \
            dbus-x11 dbus-user-session \
            x11-utils x11-apps x11-common x11-session-utils x11-xserver-utils \
            xfonts-base xfonts-100dpi xfonts-75dpi xfonts-cyrillic \
            xubuntu-icon-theme xubuntu-wallpapers gnome-icon-theme

      - name: Install Google Chrome
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
          sudo dpkg -i google-chrome-stable_current_amd64.deb || sudo apt-get install -f -y
          rm google-chrome-stable_current_amd64.deb
          google-chrome --version
          echo "‚úÖ Chrome installed"

      - name: Install TurboVNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          wget -q https://phoenixnap.dl.sourceforge.net/project/turbovnc/2.2.5/turbovnc_2.2.5_amd64.deb
          sudo dpkg -i turbovnc_2.2.5_amd64.deb
          rm turbovnc_2.2.5_amd64.deb

      - name: Install noVNC
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          cd ~
          git clone https://github.com/novnc/noVNC.git
          cd noVNC && git clone https://github.com/novnc/websockify.git

      - name: Configure and Start VNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          mkdir -p ~/.vnc
          echo "${{ steps.config.outputs.vnc_password }}" | vncpasswd -f > ~/.vnc/passwd
          chmod 600 ~/.vnc/passwd

          cat > ~/.vnc/xstartup.turbovnc << 'EOF'
          #!/bin/bash
          export NO_AT_BRIDGE=1
          export SESSION_MANAGER=""
          dbus-launch /usr/bin/startxfce4 &
          EOF
          chmod +x ~/.vnc/xstartup.turbovnc

          vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT 2>&1 | tee /tmp/vnc-start.log
          sleep 8
          pgrep -f "Xvnc.*:1" > /dev/null && echo "‚úÖ VNC started" || { cat /tmp/vnc-start.log; exit 1; }

      - name: Install Python dependencies
        if: steps.config.outputs.vnc_enabled == 'true'
        run: pip install numpy websocket-client

      - name: Start noVNC
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          cd ~/noVNC
          [ ! -f ./utils/websockify/run ] && cd utils && git clone https://github.com/novnc/websockify.git && cd ..
          ./utils/novnc_proxy --vnc localhost:$VNC_PORT --listen $NOVNC_PORT &
          sleep 5
          ss -tuln | grep -q ":$NOVNC_PORT " && echo "‚úÖ noVNC started" || echo "‚ö†Ô∏è noVNC port check failed (may still be binding)"

      - name: Download and Setup BotXByte Extension
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          EXTENSION_DIR="$HOME/real-botxbyte-extension"

          wget -q -O /tmp/real-botxbyte-extension.zip "https://github.com/user-attachments/files/25434674/real-botxbyte-extension.zip"
          TEMP_EXTRACT="/tmp/extension-extract"
          rm -rf "$TEMP_EXTRACT" && mkdir -p "$TEMP_EXTRACT"
          unzip -o /tmp/real-botxbyte-extension.zip -d "$TEMP_EXTRACT"
          rm /tmp/real-botxbyte-extension.zip

          MANIFEST_PATH=$(find "$TEMP_EXTRACT" -name "manifest.json" -type f | head -1)
          [ -z "$MANIFEST_PATH" ] && echo "‚ùå manifest.json not found" && exit 1

          ACTUAL_EXT_DIR=$(dirname "$MANIFEST_PATH")
          rm -rf "$EXTENSION_DIR"
          mv "$ACTUAL_EXT_DIR" "$EXTENSION_DIR"
          rm -rf "$TEMP_EXTRACT"

          # Remove stale/problematic files
          rm -rf "$EXTENSION_DIR/_metadata"
          rm -rf "$EXTENSION_DIR/.git"
          rm -f "$EXTENSION_DIR/.gitignore" "$EXTENSION_DIR/.env.dev" "$EXTENSION_DIR/README.md" "$EXTENSION_DIR/llm.txt"

          # ----------------------------------------------------------------
          # CRITICAL DIAGNOSTIC: Validate the manifest before launching Chrome
          # A bad manifest is the #1 reason Chrome silently refuses to load
          # an extension, even via --load-extension.
          # ----------------------------------------------------------------
          echo "=== manifest.json ==="
          cat "$EXTENSION_DIR/manifest.json"
          echo ""

          echo "=== Manifest validation ==="
          python3 << 'PYEOF'
          import json, sys, os

          ext_dir = os.path.expanduser("~/real-botxbyte-extension")
          mf_path = os.path.join(ext_dir, "manifest.json")

          try:
              with open(mf_path) as f:
                  m = json.load(f)
          except json.JSONDecodeError as e:
              print(f"‚ùå INVALID JSON in manifest.json: {e}")
              sys.exit(1)

          print(f"‚úÖ manifest.json is valid JSON")
          print(f"  Name: {m.get('name','?')}")
          print(f"  Version: {m.get('version','?')}")
          print(f"  Manifest version: {m.get('manifest_version','?')}")

          # Check manifest version
          mv = m.get('manifest_version', 0)
          if mv not in (2, 3):
              print(f"‚ùå manifest_version must be 2 or 3, got: {mv}")
              sys.exit(1)

          # For MV3: background must use service_worker, not scripts
          bg = m.get('background', {})
          if mv == 3:
              if 'scripts' in bg and 'service_worker' not in bg:
                  print(f"‚ùå MV3 background must use 'service_worker', not 'scripts'")
                  sys.exit(1)
              if 'service_worker' in bg:
                  sw_path = os.path.join(ext_dir, bg['service_worker'])
                  if not os.path.exists(sw_path):
                      print(f"‚ùå service_worker file missing: {bg['service_worker']}")
                      sys.exit(1)
                  print(f"‚úÖ service_worker: {bg['service_worker']} exists")

          # For MV2: check background scripts exist
          if mv == 2 and 'scripts' in bg:
              for s in bg['scripts']:
                  sp = os.path.join(ext_dir, s)
                  if not os.path.exists(sp):
                      print(f"‚ùå background script missing: {s}")
                  else:
                      print(f"‚úÖ background script: {s} exists")

          # Check content scripts exist
          for cs in m.get('content_scripts', []):
              for js in cs.get('js', []):
                  p = os.path.join(ext_dir, js)
                  if not os.path.exists(p):
                      print(f"‚ùå content script missing: {js}")
                  else:
                      print(f"‚úÖ content script: {js} exists")

          # Check for web_accessible_resources format (MV3 changed this)
          war = m.get('web_accessible_resources', [])
          if mv == 3 and war and isinstance(war[0], str):
              print(f"‚ùå MV3 web_accessible_resources must be objects with 'resources' and 'matches', not strings")
              sys.exit(1)

          # Check icons exist
          for size, path in m.get('icons', {}).items():
              p = os.path.join(ext_dir, path)
              if not os.path.exists(p):
                  print(f"‚ö†Ô∏è icon missing: {path} (size {size})")

          # Check action/browser_action
          action = m.get('action') or m.get('browser_action') or {}
          for k in ['default_popup', 'default_icon']:
              v = action.get(k)
              if v and isinstance(v, str):
                  p = os.path.join(ext_dir, v)
                  if not os.path.exists(p):
                      print(f"‚ö†Ô∏è action file missing: {v}")

          print("")
          print("=== All extension files ===")
          for root, dirs, files in os.walk(ext_dir):
              dirs[:] = [d for d in dirs if d not in ['.git', '__pycache__', 'node_modules']]
              level = root.replace(ext_dir, '').count(os.sep)
              indent = '  ' * level
              print(f'{indent}{os.path.basename(root)}/')
              for f in files:
                  fp = os.path.join(root, f)
                  size = os.path.getsize(fp)
                  print(f'{indent}  {f} ({size} bytes)')

          print("\n‚úÖ Manifest validation passed")
          PYEOF

          # Install Python deps
          [ -f "$EXTENSION_DIR/requirements.txt" ] && pip install -r "$EXTENSION_DIR/requirements.txt" || true

          echo "‚úÖ Extension setup complete at: $EXTENSION_DIR"

      - name: Start BotXByte Server
        if: steps.config.outputs.vnc_enabled == 'true'
        id: botxbyte_server
        run: |
          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
          cd "$EXTENSION_DIR"
          nohup python3 server.py > /tmp/botxbyte-server.log 2>&1 &
          SERVER_PID=$!
          echo "server_pid=$SERVER_PID" >> $GITHUB_OUTPUT
          sleep 3
          kill -0 $SERVER_PID 2>/dev/null && echo "‚úÖ BotXByte server started (PID: $SERVER_PID)" || { echo "‚ùå Server failed"; cat /tmp/botxbyte-server.log; exit 1; }

      - name: Launch Chrome with BotXByte Extension
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export DISPLAY=:1
          export NO_AT_BRIDGE=1
          export DBUS_SESSION_BUS_ADDRESS=/dev/null

          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          CHROME_PROFILE_DIR="$HOME/chrome-botxbyte-profile"

          rm -rf "$CHROME_PROFILE_DIR"
          mkdir -p "$CHROME_PROFILE_DIR/Default"
          rm -rf "$EXTENSION_DIR/_metadata"

          # ----------------------------------------------------------------
          # Chrome policy: allow unpacked extensions and developer mode
          # ----------------------------------------------------------------
          sudo mkdir -p /etc/opt/chrome/policies/managed
          cat << 'POLICY' | sudo tee /etc/opt/chrome/policies/managed/policy.json > /dev/null
          {
            "ExtensionSettings": {
              "*": { "installation_mode": "allowed" }
            },
            "DeveloperToolsAvailability": 1,
            "ExtensionDeveloperModeAllowed": true,
            "BlockExternalExtensions": false,
            "CommandLineFlagSecurityWarningsEnabled": false
          }
          POLICY

          # ----------------------------------------------------------------
          # Pre-seed Preferences BEFORE Chrome launches.
          # This tells Chrome developer mode is already on.
          # Chrome will re-compute HMACs itself on first read.
          # ----------------------------------------------------------------
          cat > "$CHROME_PROFILE_DIR/Default/Preferences" << 'PREFS_EOF'
          {
            "extensions": {
              "ui": {
                "developer_mode": true
              },
              "alerts": {
                "initialized": true
              }
            },
            "profile": {
              "exit_type": "Normal",
              "exited_cleanly": true
            },
            "browser": {
              "has_seen_welcome_page": true
            }
          }
          PREFS_EOF

          touch "$CHROME_PROFILE_DIR/First Run"

          # ----------------------------------------------------------------
          # Launch Chrome with extension.
          #
          # KEY FLAGS EXPLAINED:
          # --load-extension          : Load unpacked extension from path
          # --no-sandbox              : Required on GitHub runners (no user namespace)
          # --disable-extensions-except: NOT used ‚Äî this would BLOCK our extension!
          # --allow-legacy-extension-manifests: accept both MV2 and MV3
          # ----------------------------------------------------------------
          echo "Launching Chrome..."
          google-chrome \
            --no-first-run \
            --no-default-browser-check \
            --disable-gpu \
            --no-sandbox \
            --disable-dev-shm-usage \
            --enable-extensions \
            --load-extension="$EXTENSION_DIR" \
            --allow-legacy-extension-manifests \
            --user-data-dir="$CHROME_PROFILE_DIR" \
            --remote-debugging-port=9222 \
            --new-window \
            "about:blank" \
            2>/tmp/chrome-stderr.log &

          CHROME_PID=$!
          echo "Chrome PID: $CHROME_PID"

          # Wait for Chrome to fully start (longer wait = more reliable)
          sleep 20

          if ! pgrep -f "google-chrome" > /dev/null; then
            echo "‚ùå Chrome crashed on launch"
            echo "=== Chrome stderr ==="
            cat /tmp/chrome-stderr.log
            exit 1
          fi
          echo "‚úÖ Chrome is running"

          # Check stderr for extension errors
          echo "=== Chrome stderr (extension-related lines) ==="
          grep -i "extension\|load\|error\|warn\|manifest\|crx" /tmp/chrome-stderr.log 2>/dev/null | head -30 || echo "(no matching lines)"

          # ----------------------------------------------------------------
          # Verify via CDP ‚Äî wait for extension service worker to appear
          # ----------------------------------------------------------------
          python3 << 'PYEOF'
          import websocket, json, time, urllib.request, sys

          def cdp_http(path):
              try:
                  resp = urllib.request.urlopen(f"http://localhost:9222{path}", timeout=10)
                  return json.loads(resp.read())
              except Exception as e:
                  print(f"  CDP HTTP error on {path}: {e}")
                  return None

          def cdp_send(ws, method, params=None, msg_id=1):
              msg = {"id": msg_id, "method": method}
              if params:
                  msg["params"] = params
              ws.send(json.dumps(msg))
              for _ in range(100):
                  resp = json.loads(ws.recv())
                  if resp.get("id") == msg_id:
                      return resp
              return {}

          # Poll for extension service worker (up to 30 seconds)
          print("Waiting for extension service worker...")
          ext_sw = None
          for attempt in range(15):
              time.sleep(2)
              targets = cdp_http("/json/list") or []
              for t in targets:
                  if t.get("type") == "service_worker" and "nmmhkkegccagdldgiimedpiccmgmieda" not in t.get("url",""):
                      ext_sw = t
                      break
              if ext_sw:
                  break
              print(f"  Attempt {attempt+1}/15: no extension service worker yet... ({len(targets)} targets)")

          print("\n=== All CDP targets ===")
          targets = cdp_http("/json/list") or []
          for t in targets:
              print(f"  [{t.get('type','?')}] {t.get('url','?')[:100]}")

          if ext_sw:
              print(f"\n‚úÖ Extension service worker ACTIVE: {ext_sw.get('url')}")
              sw_id = ext_sw.get('url','').split('/')[2] if '/' in ext_sw.get('url','') else 'unknown'
              print(f"  Extension ID: {sw_id}")
          else:
              print("\n‚ö†Ô∏è  Extension service worker NOT found")
              print("Possible causes:")
              print("  1. manifest.json has errors Chrome rejected silently")
              print("  2. The extension uses MV2 (background page, not service worker)")
              print("  3. Chrome blocked --load-extension for security reasons")

              # For MV2 extensions, look for background_page instead
              mv2_bg = [t for t in targets if t.get("type") == "background_page"
                        and "nmmhkkegccagdldgiimedpiccmgmieda" not in t.get("url","")]
              if mv2_bg:
                  print(f"\n‚úÖ Found MV2 background page (extension IS loaded):")
                  for t in mv2_bg:
                      print(f"  {t.get('url')}")

          # Check chrome://extensions via CDP to see what's shown in UI
          print("\n=== chrome://extensions UI check ===")
          # Navigate a tab to chrome://extensions
          tab_list = cdp_http("/json/list") or []
          page_tab = next((t for t in tab_list if t.get("type") == "page"), None)

          if page_tab and page_tab.get("webSocketDebuggerUrl"):
              try:
                  ws = websocket.create_connection(page_tab["webSocketDebuggerUrl"], timeout=15)
                  # Navigate to extensions page
                  cdp_send(ws, "Page.navigate", {"url": "chrome://extensions"}, msg_id=10)
                  time.sleep(4)

                  result = cdp_send(ws, "Runtime.evaluate", {
                      "expression": """
                      (async function() {
                          // Wait for shadow DOM to be ready
                          for (let i = 0; i < 20; i++) {
                              const manager = document.querySelector('extensions-manager');
                              if (manager && manager.shadowRoot) {
                                  const toolbar = manager.shadowRoot.querySelector('extensions-toolbar');
                                  const devMode = toolbar?.shadowRoot?.querySelector('#devMode')?.checked;
                                  const items = Array.from(manager.shadowRoot.querySelectorAll('extensions-item'));
                                  const exts = items.map(item => ({
                                      name: item.shadowRoot?.querySelector('#name')?.textContent?.trim() || 'unknown',
                                      id: item.getAttribute('id') || '?',
                                      enabled: !item.shadowRoot?.querySelector('cr-toggle')?.hasAttribute('disabled')
                                  }));
                                  return JSON.stringify({devMode, extensions: exts, ready: true});
                              }
                              await new Promise(r => setTimeout(r, 500));
                          }
                          return JSON.stringify({error: 'extensions-manager not found', ready: false});
                      })()
                      """,
                      "awaitPromise": True
                  }, msg_id=11)

                  val = result.get("result",{}).get("result",{}).get("value","{}") or "{}"
                  try:
                      data = json.loads(val)
                      if data.get("error"):
                          print(f"  ‚ö†Ô∏è {data['error']}")
                      else:
                          print(f"  Developer mode: {'ON ‚úÖ' if data.get('devMode') else 'OFF ‚ö†Ô∏è'}")
                          exts = data.get("extensions", [])
                          print(f"  Extensions in UI: {len(exts)}")
                          for e in exts:
                              status = "‚úÖ" if e.get("enabled") else "‚ö†Ô∏è disabled"
                              print(f"    {status} {e.get('name')} (ID: {e.get('id')})")
                          if not exts:
                              print("  ‚ùå No extensions shown in chrome://extensions")
                  except Exception as parse_err:
                      print(f"  Parse error: {parse_err}, raw: {val[:200]}")

                  ws.close()
              except Exception as e:
                  print(f"  CDP error: {e}")

          version = cdp_http("/json/version") or {}
          print(f"\nChrome version: {version.get('Browser','?')}")
          PYEOF

          echo ""
          echo "=== Summary ==="
          pgrep -f "google-chrome" > /dev/null && echo "‚úÖ Chrome: running" || echo "‚ùå Chrome: NOT running"
          pgrep -f "server.py" > /dev/null && echo "‚úÖ BotXByte server: running" || echo "‚ö†Ô∏è BotXByte server: NOT running"

      - name: Install cloudflared
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          cloudflared --version

      - name: Create Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        id: tunnel
        run: |
          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel" \
            --request POST \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data '{"name":"github-vnc-'"$(date +%s)"'","config_src":"cloudflare"}')

          SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false')
          [ "$SUCCESS" != "true" ] && echo "‚ùå Failed to create tunnel" && echo "$RESPONSE" | jq '.' && exit 1

          echo "tunnel_id=$(echo "$RESPONSE" | jq -r '.result.id')" >> $GITHUB_OUTPUT
          echo "tunnel_token=$(echo "$RESPONSE" | jq -r '.result.token')" >> $GITHUB_OUTPUT
          echo "‚úÖ Tunnel created"

      - name: Configure Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel/${{ steps.tunnel.outputs.tunnel_id }}/configurations" \
            --request PUT \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data "{\"config\":{\"ingress\":[
              {\"hostname\":\"${{ steps.config.outputs.hostname }}\",\"path\":\"/vnc/*\",\"service\":\"http://localhost:${NOVNC_PORT}\",\"originRequest\":{}},
              {\"hostname\":\"${{ steps.config.outputs.hostname }}\",\"path\":\"/browser-agent-management-service/*\",\"service\":\"http://localhost:8801\",\"originRequest\":{}},
              {\"hostname\":\"${{ steps.config.outputs.hostname }}\",\"service\":\"http://localhost:${NOVNC_PORT}\",\"originRequest\":{}},
              {\"service\":\"http_status:404\"}
            ]}}")
          echo "$RESPONSE" | jq -r '.success' | grep -q true && echo "‚úÖ Tunnel configured" || { echo "‚ùå Tunnel config failed"; echo "$RESPONSE" | jq '.'; exit 1; }

      - name: Create DNS Record
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          EXISTING=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records?name=${FULL_HOSTNAME}" \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" | jq -r '.result[0].id // empty')
          [ -n "$EXISTING" ] && curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records/${EXISTING}" \
            --request DELETE --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" > /dev/null && sleep 2

          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records" \
            --request POST \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data "{\"type\":\"CNAME\",\"proxied\":true,\"name\":\"${FULL_HOSTNAME}\",\"content\":\"${{ steps.tunnel.outputs.tunnel_id }}.cfargotunnel.com\"}")
          echo "$RESPONSE" | jq -r '.success' | grep -q true && echo "‚úÖ DNS created" || { echo "‚ùå DNS failed"; echo "$RESPONSE" | jq '.errors'; exit 1; }

      - name: Start Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
          sleep 10
          pgrep -x cloudflared > /dev/null && echo "‚úÖ Tunnel started" || { echo "‚ùå Tunnel failed"; cat /tmp/tunnel.log; exit 1; }

      - name: Display VNC Connection Info
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "üåê Access: https://${{ steps.config.outputs.hostname }}/vnc.html"

      - name: Run Moti on Desktop
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export DISPLAY=:1 NO_AT_BRIDGE=1 SESSION_MANAGER="" DBUS_SESSION_BUS_ADDRESS=/dev/null
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ffmpeg \
            libavcodec-dev libavformat-dev libavdevice-dev libavutil-dev \
            libavfilter-dev libswscale-dev libswresample-dev pkg-config

          xfce4-terminal --maximize --title="Moti Process" \
            --command="bash -c 'export MOTI_JOB_CONFIG=\$(echo \"${{ inputs.base64_config }}\" | base64 -d) && pip install av --upgrade && pip install moti && moti; echo Done; read'" 2>/dev/null &
          sleep 5
          pgrep -f "xfce4-terminal" > /dev/null && echo "‚úÖ Moti terminal launched" || echo "‚ö†Ô∏è Terminal may not have started"

      - name: Run Moti in Normal Terminal
        if: steps.config.outputs.vnc_enabled == 'false'
        timeout-minutes: 30
        run: |
          export MOTI_JOB_CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)
          pip install moti && moti
          echo "‚úÖ Moti completed"

      - name: Keep VNC Session Alive
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          export DBUS_SESSION_BUS_ADDRESS=/dev/null
          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          CHROME_PROFILE_DIR="$HOME/chrome-botxbyte-profile"

          # 355 minutes = job timeout (360) minus 5 min buffer for cleanup
          END_TIME=$((SECONDS + 21300))

          while [ $SECONDS -lt $END_TIME ]; do
            REMAINING=$((END_TIME - SECONDS))
            echo "‚è±Ô∏è Remaining: $((REMAINING/3600))h $(((REMAINING%3600)/60))m"

            # Restart VNC if crashed
            if ! pgrep -f "Xvnc.*:1" > /dev/null; then
              echo "‚ùå VNC stopped, restarting..."
              vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT && echo "‚úÖ VNC restarted" || exit 1
            fi

            # Restart cloudflared if crashed
            if [ "${{ steps.config.outputs.cloudflare_enabled }}" = "true" ] && ! pgrep -x cloudflared > /dev/null; then
              echo "‚ùå Tunnel stopped, restarting..."
              cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
              sleep 5
              pgrep -x cloudflared > /dev/null && echo "‚úÖ Tunnel restarted" || { cat /tmp/tunnel.log; exit 1; }
            fi

            # Restart BotXByte server if crashed
            if ! pgrep -f "server.py" > /dev/null; then
              echo "‚ùå BotXByte server stopped, restarting..."
              cd "$EXTENSION_DIR"
              export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
              nohup python3 server.py > /tmp/botxbyte-server.log 2>&1 &
              sleep 3
              pgrep -f "server.py" > /dev/null && echo "‚úÖ Server restarted" || cat /tmp/botxbyte-server.log
            fi

            # Restart Chrome if crashed
            if ! pgrep -f "google-chrome" > /dev/null; then
              echo "‚ùå Chrome stopped, restarting..."
              export DISPLAY=:1 NO_AT_BRIDGE=1 DBUS_SESSION_BUS_ADDRESS=/dev/null
              rm -rf "$EXTENSION_DIR/_metadata"
              google-chrome \
                --no-first-run --no-default-browser-check \
                --disable-gpu --no-sandbox --disable-dev-shm-usage \
                --enable-extensions \
                --load-extension="$EXTENSION_DIR" \
                --allow-legacy-extension-manifests \
                --user-data-dir="$CHROME_PROFILE_DIR" \
                --remote-debugging-port=9222 \
                --new-window "about:blank" \
                2>/tmp/chrome-stderr.log &
              sleep 8
              pgrep -f "google-chrome" > /dev/null && echo "‚úÖ Chrome restarted" || echo "‚ö†Ô∏è Chrome failed to restart"
            fi

            sleep 30
          done
          echo "‚úÖ Session complete"

      - name: Cleanup Webshare
        if: always() && steps.config.outputs.webshare_enabled == 'true'
        run: |
          AUTH_ID="${{ steps.webshare.outputs.webshare_auth_id }}"
          [ -n "$AUTH_ID" ] && [ "$AUTH_ID" != "null" ] && \
            curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/${AUTH_ID}/" \
              -X DELETE -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}" > /dev/null && \
            echo "‚úÖ Webshare IP deregistered"

      - name: Cleanup BotXByte
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          pkill -f "google-chrome" || true
          pkill -f "server.py" || true
          echo "‚úÖ BotXByte cleanup done"

      - name: Cleanup Cloudflare
        if: always() && steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          pkill -x cloudflared || true
          sleep 2

          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          ACCT="${{ steps.config.outputs.cloudflare_account_id }}"
          ZONE="${{ steps.config.outputs.cloudflare_zone_id }}"
          TOKEN="${{ steps.config.outputs.cloudflare_api_token }}"
          TUNNEL_ID="${{ steps.tunnel.outputs.tunnel_id }}"
          USER_ID="${{ steps.config.outputs.user_id }}"
          WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
          BROWSER_PROFILE_ID="${{ steps.config.outputs.browser_profile_id }}"

          if [ -n "$FULL_HOSTNAME" ] && [ "$FULL_HOSTNAME" != "null" ]; then
            DEL_URL="http://129.212.196.173/ai-management-service/api/v1/cloudflare-tunnel-info/delete/?tunnel_url=https://${FULL_HOSTNAME}"
            [ -n "$BROWSER_PROFILE_ID" ] && [ "$BROWSER_PROFILE_ID" != "null" ] && DEL_URL="${DEL_URL}&browser_profile_id=${BROWSER_PROFILE_ID}"
            curl -s "$DEL_URL" -X DELETE -H "user-id: ${USER_ID}" -H "workspace-id: ${WORKSPACE_ID}" > /dev/null

            DNS_ID=$(curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records?name=${FULL_HOSTNAME}" \
              --header "Authorization: Bearer ${TOKEN}" | jq -r '.result[0].id // empty')
            [ -n "$DNS_ID" ] && curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records/${DNS_ID}" \
              --request DELETE --header "Authorization: Bearer ${TOKEN}" | jq -r 'if .success then "‚úÖ DNS deleted" else "‚ö†Ô∏è DNS delete failed" end'
          fi

          [ -n "$TUNNEL_ID" ] && [ "$TUNNEL_ID" != "null" ] && \
            curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/accounts/${ACCT}/cfd_tunnel/${TUNNEL_ID}" \
              --request DELETE --header "Authorization: Bearer ${TOKEN}" | jq -r 'if .success then "‚úÖ Tunnel deleted" else "‚ö†Ô∏è Tunnel delete failed" end'

      - name: Cleanup VNC
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          vncserver -kill :1 || true
          echo "‚úÖ VNC cleanup done"
