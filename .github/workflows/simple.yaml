name: VNC Data Static Timeout
on:
  workflow_dispatch:
    inputs:
      base64_config:
        description: 'Base64 encoded JSON configuration'
        required: true
        type: string

env:
  DISPLAY: :1
  VNC_PORT: 5901
  NOVNC_PORT: 6080

jobs:
  process:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Fetch and Parse Config
        id: config
        run: |
          CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)

          VNC_ENABLED=$(echo "$CONFIG" | jq -r '.vnc_enabled // "false"')
          CLOUDFLARE_ENABLED=$(echo "$CONFIG" | jq -r '.cloudflare_enabled // "false"')
          WEBSHARE_ENABLED=$(echo "$CONFIG" | jq -r '.webshare_enabled // "false"')
          echo "vnc_enabled=$VNC_ENABLED" >> $GITHUB_OUTPUT
          echo "cloudflare_enabled=$CLOUDFLARE_ENABLED" >> $GITHUB_OUTPUT
          echo "webshare_enabled=$WEBSHARE_ENABLED" >> $GITHUB_OUTPUT

          USER_ID=$(echo "$CONFIG" | jq -r '.user_id // "69c3090b-464d-4de3-9358-ceca1c9e2aa8"')
          WORKSPACE_ID=$(echo "$CONFIG" | jq -r '.workspace_id // "ceae1caa-1538-4859-8e1a-24a8b4904d5f"')
          echo "user_id=$USER_ID" >> $GITHUB_OUTPUT
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT

          if [ "$VNC_ENABLED" = "true" ]; then
            VNC_PASSWORD=$(echo "$CONFIG" | jq -r '.vnc_password // ""')
            echo "vnc_password=$VNC_PASSWORD" >> $GITHUB_OUTPUT
          fi

          if [ "$CLOUDFLARE_ENABLED" = "true" ]; then
            echo "cloudflare_api_token=$(echo "$CONFIG" | jq -r '.cloudflare_api_token // ""')" >> $GITHUB_OUTPUT
            echo "cloudflare_account_id=$(echo "$CONFIG" | jq -r '.cloudflare_account_id // ""')" >> $GITHUB_OUTPUT
            echo "cloudflare_zone_id=$(echo "$CONFIG" | jq -r '.cloudflare_zone_id // ""')" >> $GITHUB_OUTPUT
            echo "hostname=$(echo "$CONFIG" | jq -r '.hostname // ""')" >> $GITHUB_OUTPUT
            echo "browser_profile_id=$(echo "$CONFIG" | jq -r '.browser_profile_id // ""')" >> $GITHUB_OUTPUT
          fi

          if [ "$WEBSHARE_ENABLED" = "true" ]; then
            echo "webshare_api_token=$(echo "$CONFIG" | jq -r '.webshare_api_token // ""')" >> $GITHUB_OUTPUT
          fi

          echo "‚úÖ Config: VNC=$VNC_ENABLED | Cloudflare=$CLOUDFLARE_ENABLED | Webshare=$WEBSHARE_ENABLED"

      - name: Register IP with Webshare
        if: steps.config.outputs.webshare_enabled == 'true'
        id: webshare
        run: |
          PUBLIC_IP=$(curl -s 'https://api.ipify.org?format=json' | jq -r '.ip')
          RESPONSE=$(curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/" \
            -X POST -d "{\"ip_address\": \"$PUBLIC_IP\"}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}")
          AUTH_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
          [ -n "$AUTH_ID" ] && echo "webshare_auth_id=$AUTH_ID" >> $GITHUB_OUTPUT && echo "‚úÖ IP registered (Auth ID: $AUTH_ID)" || echo "‚ö†Ô∏è Webshare registration failed"

      - name: Install Desktop Environment
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            xfce4 xfce4-goodies xfce4-terminal firefox \
            dbus-x11 dbus-user-session \
            x11-utils x11-apps x11-common x11-session-utils x11-xserver-utils \
            xfonts-base xfonts-100dpi xfonts-75dpi xfonts-cyrillic \
            xubuntu-icon-theme xubuntu-wallpapers gnome-icon-theme

      - name: Install Google Chrome
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
          sudo dpkg -i google-chrome-stable_current_amd64.deb || sudo apt-get install -f -y
          rm google-chrome-stable_current_amd64.deb
          google-chrome --version

      - name: Install TurboVNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          wget -q https://phoenixnap.dl.sourceforge.net/project/turbovnc/2.2.5/turbovnc_2.2.5_amd64.deb
          sudo dpkg -i turbovnc_2.2.5_amd64.deb
          rm turbovnc_2.2.5_amd64.deb

      - name: Install noVNC
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          cd ~
          git clone https://github.com/novnc/noVNC.git
          cd noVNC && git clone https://github.com/novnc/websockify.git

      - name: Configure and Start VNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          mkdir -p ~/.vnc
          echo "${{ steps.config.outputs.vnc_password }}" | vncpasswd -f > ~/.vnc/passwd
          chmod 600 ~/.vnc/passwd

          cat > ~/.vnc/xstartup.turbovnc << 'EOF'
          #!/bin/bash
          export NO_AT_BRIDGE=1
          export SESSION_MANAGER=""
          dbus-launch /usr/bin/startxfce4 &
          EOF
          chmod +x ~/.vnc/xstartup.turbovnc

          vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT 2>&1 | tee /tmp/vnc-start.log
          sleep 8
          pgrep -f "Xvnc.*:1" > /dev/null && echo "‚úÖ VNC started on port $VNC_PORT" || { cat /tmp/vnc-start.log; exit 1; }

      - name: Install Python dependencies
        if: steps.config.outputs.vnc_enabled == 'true'
        run: pip install numpy websocket-client

      - name: Start noVNC
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          cd ~/noVNC
          [ ! -f ./utils/websockify/run ] && cd utils && git clone https://github.com/novnc/websockify.git && cd ..
          ./utils/novnc_proxy --vnc localhost:$VNC_PORT --listen $NOVNC_PORT &
          sleep 5
          ss -tuln | grep -q ":$NOVNC_PORT " && echo "‚úÖ noVNC started on port $NOVNC_PORT" || echo "‚ö†Ô∏è noVNC may still be binding..."

      - name: Download and Setup BotXByte Extension
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          EXTENSION_DIR="$HOME/real-botxbyte-extension"

          wget -q -O /tmp/real-botxbyte-extension.zip "https://github.com/user-attachments/files/25434674/real-botxbyte-extension.zip"
          TEMP_EXTRACT="/tmp/extension-extract"
          rm -rf "$TEMP_EXTRACT" && mkdir -p "$TEMP_EXTRACT"
          unzip -o /tmp/real-botxbyte-extension.zip -d "$TEMP_EXTRACT"
          rm /tmp/real-botxbyte-extension.zip

          MANIFEST_PATH=$(find "$TEMP_EXTRACT" -name "manifest.json" -type f | head -1)
          [ -z "$MANIFEST_PATH" ] && echo "‚ùå manifest.json not found" && exit 1

          rm -rf "$EXTENSION_DIR"
          mv "$(dirname "$MANIFEST_PATH")" "$EXTENSION_DIR"
          rm -rf "$TEMP_EXTRACT"

          # Remove files Chrome doesn't want to see in extension dir
          rm -rf "$EXTENSION_DIR/_metadata" "$EXTENSION_DIR/.git"
          rm -f "$EXTENSION_DIR/.gitignore" "$EXTENSION_DIR/.env.dev" \
                "$EXTENSION_DIR/README.md" "$EXTENSION_DIR/llm.txt"

          echo "=== manifest.json ==="
          cat "$EXTENSION_DIR/manifest.json"
          echo ""
          echo "=== Extension files ==="
          find "$EXTENSION_DIR" -type f | sort

          [ -f "$EXTENSION_DIR/requirements.txt" ] && pip install -r "$EXTENSION_DIR/requirements.txt" || true
          echo "‚úÖ Extension ready at: $EXTENSION_DIR"

      - name: Start BotXByte Server
        if: steps.config.outputs.vnc_enabled == 'true'
        id: botxbyte_server
        run: |
          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
          cd "$EXTENSION_DIR"
          nohup python3 server.py > /tmp/botxbyte-server.log 2>&1 &
          SERVER_PID=$!
          echo "server_pid=$SERVER_PID" >> $GITHUB_OUTPUT
          sleep 3
          kill -0 $SERVER_PID 2>/dev/null \
            && echo "‚úÖ BotXByte server started (PID: $SERVER_PID)" \
            || { echo "‚ùå Server failed to start"; cat /tmp/botxbyte-server.log; exit 1; }

      - name: Launch Chrome with BotXByte Extension
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export DISPLAY=:1
          export NO_AT_BRIDGE=1
          export DBUS_SESSION_BUS_ADDRESS=/dev/null

          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          CHROME_PROFILE_DIR="$HOME/chrome-botxbyte-profile"

          rm -rf "$CHROME_PROFILE_DIR"
          mkdir -p "$CHROME_PROFILE_DIR/Default"
          rm -rf "$EXTENSION_DIR/_metadata"

          # Allow unpacked extensions via policy
          sudo mkdir -p /etc/opt/chrome/policies/managed
          cat << 'POLICY' | sudo tee /etc/opt/chrome/policies/managed/policy.json > /dev/null
          {
            "ExtensionSettings": {
              "*": { "installation_mode": "allowed" }
            },
            "DeveloperToolsAvailability": 1,
            "ExtensionDeveloperModeAllowed": true,
            "BlockExternalExtensions": false
          }
          POLICY

          # Pre-seed Preferences with developer_mode ON before Chrome starts
          # Chrome reads this on first launch and re-computes HMACs itself
          cat > "$CHROME_PROFILE_DIR/Default/Preferences" << 'PREFS_EOF'
          {
            "extensions": {
              "ui": { "developer_mode": true },
              "alerts": { "initialized": true }
            },
            "profile": {
              "exit_type": "Normal",
              "exited_cleanly": true
            },
            "browser": {
              "has_seen_welcome_page": true
            }
          }
          PREFS_EOF

          touch "$CHROME_PROFILE_DIR/First Run"

          echo "Launching Chrome with extension..."
          google-chrome \
            --no-first-run \
            --no-default-browser-check \
            --disable-gpu \
            --no-sandbox \
            --disable-dev-shm-usage \
            --enable-extensions \
            --load-extension="$EXTENSION_DIR" \
            --allow-legacy-extension-manifests \
            --user-data-dir="$CHROME_PROFILE_DIR" \
            --remote-debugging-port=9222 \
            --remote-allow-origins='*' \
            --new-window \
            "about:blank" \
            2>/tmp/chrome-stderr.log &

          CHROME_PID=$!
          echo "Chrome PID: $CHROME_PID"
          sleep 20

          if ! pgrep -f "google-chrome" > /dev/null; then
            echo "‚ùå Chrome crashed"
            cat /tmp/chrome-stderr.log
            exit 1
          fi
          echo "‚úÖ Chrome is running"

          # Show only genuine errors (skip known harmless dbus noise)
          echo "=== Chrome errors (non-dbus) ==="
          grep -i "ERROR\|WARN\|extension\|manifest\|crx\|load" /tmp/chrome-stderr.log \
            | grep -v "dbus\|DBus\|NameHasOwner\|PHONE_REGISTRATION" \
            | head -20 \
            || echo "(none)"

          # ----------------------------------------------------------------
          # Verify extension loaded via CDP
          # The extension IS confirmed loaded when service_worker appears.
          # We also check chrome://extensions UI for confirmation.
          # ----------------------------------------------------------------
          python3 << 'PYEOF'
          import websocket, json, time, urllib.request

          def cdp_http(path):
              try:
                  resp = urllib.request.urlopen(f"http://localhost:9222{path}", timeout=10)
                  return json.loads(resp.read())
              except Exception as e:
                  print(f"  CDP HTTP error: {e}")
                  return None

          def cdp_send(ws, method, params=None, msg_id=1):
              msg = {"id": msg_id, "method": method}
              if params:
                  msg["params"] = params
              ws.send(json.dumps(msg))
              for _ in range(200):
                  try:
                      resp = json.loads(ws.recv())
                      if resp.get("id") == msg_id:
                          return resp
                  except:
                      break
              return {}

          # ---- Step 1: Find extension by scanning all targets ----
          print("Scanning CDP targets for extension...")
          ext_id = None
          ext_sw = None
          ext_bg = None  # MV2 background page

          for attempt in range(10):
              time.sleep(2)
              targets = cdp_http("/json/list") or []
              for t in targets:
                  url = t.get("url", "")
                  ttype = t.get("type", "")
                  # Skip built-in Chrome extensions
                  if "nmmhkkegccagdldgiimedpiccmgmieda" in url:
                      continue
                  if ttype == "service_worker" and url.startswith("chrome-extension://"):
                      ext_sw = t
                      ext_id = url.split("/")[2]
                      break
                  if ttype == "background_page" and url.startswith("chrome-extension://"):
                      ext_bg = t
                      ext_id = url.split("/")[2]
                      break
              if ext_id:
                  break
              print(f"  Attempt {attempt+1}/10 ‚Äî waiting... ({len(targets)} targets total)")

          print("\n=== All CDP targets ===")
          for t in cdp_http("/json/list") or []:
              print(f"  [{t.get('type','?')}] {t.get('url','?')[:120]}")

          if ext_sw:
              print(f"\n‚úÖ Extension loaded (MV3 Service Worker)")
              print(f"   ID  : {ext_id}")
              print(f"   URL : {ext_sw.get('url')}")
          elif ext_bg:
              print(f"\n‚úÖ Extension loaded (MV2 Background Page)")
              print(f"   ID  : {ext_id}")
              print(f"   URL : {ext_bg.get('url')}")
          else:
              print("\n‚ùå Extension NOT found in any CDP target")
              print("   Check manifest.json for errors and that all referenced files exist")

          # ---- Step 2: Open chrome://extensions and read the UI ----
          print("\n=== chrome://extensions UI ===")
          targets = cdp_http("/json/list") or []
          page_tab = next((t for t in targets if t.get("type") == "page"), None)

          if not page_tab:
              print("  No page tab available to navigate")
          else:
              ws_url = page_tab.get("webSocketDebuggerUrl")
              if not ws_url:
                  print("  No WebSocket debugger URL")
              else:
                  try:
                      ws = websocket.create_connection(ws_url, timeout=15)
                      cdp_send(ws, "Page.navigate", {"url": "chrome://extensions"}, msg_id=1)
                      time.sleep(5)  # Give page time to fully render

                      result = cdp_send(ws, "Runtime.evaluate", {
                          "expression": """
                          (async () => {
                              for (let i = 0; i < 30; i++) {
                                  const mgr = document.querySelector('extensions-manager');
                                  if (mgr && mgr.shadowRoot) {
                                      const toolbar = mgr.shadowRoot.querySelector('extensions-toolbar');
                                      const devMode = toolbar?.shadowRoot?.querySelector('#devMode')?.checked ?? false;
                                      const items = [...mgr.shadowRoot.querySelectorAll('extensions-item')];
                                      return JSON.stringify({
                                          devMode,
                                          count: items.length,
                                          extensions: items.map(item => ({
                                              name: item.shadowRoot?.querySelector('#name')?.textContent?.trim() ?? '?',
                                              id: item.id ?? '?',
                                              enabled: item.shadowRoot?.querySelector('cr-toggle')?.checked ?? false,
                                              hasError: !!item.shadowRoot?.querySelector('.errors-button')
                                          }))
                                      });
                                  }
                                  await new Promise(r => setTimeout(r, 500));
                              }
                              return JSON.stringify({error: 'shadow DOM not ready after 15s'});
                          })()
                          """,
                          "awaitPromise": True
                      }, msg_id=2)

                      raw = result.get("result",{}).get("result",{}).get("value","{}") or "{}"
                      data = json.loads(raw)

                      if "error" in data:
                          print(f"  ‚ö†Ô∏è  {data['error']}")
                      else:
                          dm = "ON ‚úÖ" if data.get("devMode") else "OFF ‚ö†Ô∏è"
                          print(f"  Developer mode : {dm}")
                          print(f"  Extensions shown: {data.get('count', 0)}")
                          for e in data.get("extensions", []):
                              status = "‚úÖ enabled" if e.get("enabled") else "‚ö†Ô∏è disabled"
                              err    = " ‚ö†Ô∏è HAS ERROR" if e.get("hasError") else ""
                              print(f"    {status}{err} ‚Äî {e.get('name')} (ID: {e.get('id')})")

                          if data.get("count", 0) == 0:
                              print("  ‚ùå No extensions in UI ‚Äî Chrome rejected the extension")
                              print("     Most likely cause: manifest.json references a missing file")

                      ws.close()
                  except Exception as e:
                      print(f"  CDP error: {e}")

          version = cdp_http("/json/version") or {}
          print(f"\nChrome: {version.get('Browser','?')}")
          PYEOF

          echo ""
          echo "=== Final Status ==="
          pgrep -f "google-chrome" > /dev/null && echo "‚úÖ Chrome        : running" || echo "‚ùå Chrome        : NOT running"
          pgrep -f "server.py"     > /dev/null && echo "‚úÖ BotXByte srv  : running" || echo "‚ö†Ô∏è BotXByte srv  : NOT running"

      - name: Install cloudflared
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          cloudflared --version

      - name: Create Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        id: tunnel
        run: |
          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel" \
            --request POST \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data '{"name":"github-vnc-'"$(date +%s)"'","config_src":"cloudflare"}')
          [ "$(echo "$RESPONSE" | jq -r '.success')" != "true" ] && echo "$RESPONSE" | jq '.' && exit 1
          echo "tunnel_id=$(echo "$RESPONSE" | jq -r '.result.id')" >> $GITHUB_OUTPUT
          echo "tunnel_token=$(echo "$RESPONSE" | jq -r '.result.token')" >> $GITHUB_OUTPUT
          echo "‚úÖ Tunnel created"

      - name: Configure Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel/${{ steps.tunnel.outputs.tunnel_id }}/configurations" \
            --request PUT \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data "{\"config\":{\"ingress\":[
              {\"hostname\":\"${{ steps.config.outputs.hostname }}\",\"path\":\"/vnc/*\",\"service\":\"http://localhost:${NOVNC_PORT}\",\"originRequest\":{}},
              {\"hostname\":\"${{ steps.config.outputs.hostname }}\",\"path\":\"/browser-agent-management-service/*\",\"service\":\"http://localhost:8801\",\"originRequest\":{}},
              {\"hostname\":\"${{ steps.config.outputs.hostname }}\",\"service\":\"http://localhost:${NOVNC_PORT}\",\"originRequest\":{}},
              {\"service\":\"http_status:404\"}
            ]}}")
          [ "$(echo "$RESPONSE" | jq -r '.success')" = "true" ] && echo "‚úÖ Tunnel configured" || { echo "$RESPONSE" | jq '.'; exit 1; }

      - name: Create DNS Record
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          ZONE="${{ steps.config.outputs.cloudflare_zone_id }}"
          TOKEN="${{ steps.config.outputs.cloudflare_api_token }}"

          EXISTING=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records?name=${FULL_HOSTNAME}" \
            --header "Authorization: Bearer ${TOKEN}" | jq -r '.result[0].id // empty')
          [ -n "$EXISTING" ] && curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records/${EXISTING}" \
            --request DELETE --header "Authorization: Bearer ${TOKEN}" > /dev/null && sleep 2

          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records" \
            --request POST \
            --header "Authorization: Bearer ${TOKEN}" \
            --header "Content-Type: application/json" \
            --data "{\"type\":\"CNAME\",\"proxied\":true,\"name\":\"${FULL_HOSTNAME}\",\"content\":\"${{ steps.tunnel.outputs.tunnel_id }}.cfargotunnel.com\"}")
          [ "$(echo "$RESPONSE" | jq -r '.success')" = "true" ] && echo "‚úÖ DNS created" || { echo "$RESPONSE" | jq '.errors'; exit 1; }

      - name: Start Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
          sleep 10
          pgrep -x cloudflared > /dev/null && echo "‚úÖ Tunnel started" || { cat /tmp/tunnel.log; exit 1; }

      - name: Display VNC Connection Info
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë         üéâ VNC + BotXByte Extension is LIVE! üéâ          ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo "üåê URL      : https://${{ steps.config.outputs.hostname }}/vnc.html"
          echo "üîå WS API   : ws://localhost:8765"
          echo "üîå HTTP API : http://localhost:8766"

      - name: Run Moti on Desktop
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export DISPLAY=:1 NO_AT_BRIDGE=1 SESSION_MANAGER="" DBUS_SESSION_BUS_ADDRESS=/dev/null
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ffmpeg \
            libavcodec-dev libavformat-dev libavdevice-dev libavutil-dev \
            libavfilter-dev libswscale-dev libswresample-dev pkg-config

          xfce4-terminal --maximize --title="Moti Process" \
            --command="bash -c 'export MOTI_JOB_CONFIG=\$(echo \"${{ inputs.base64_config }}\" | base64 -d) && pip install av --upgrade && pip install moti && moti; echo Done; read'" 2>/dev/null &
          sleep 5
          pgrep -f "xfce4-terminal" > /dev/null && echo "‚úÖ Moti started" || echo "‚ö†Ô∏è Terminal may not have launched"

      - name: Run Moti in Normal Terminal
        if: steps.config.outputs.vnc_enabled == 'false'
        timeout-minutes: 30
        run: |
          export MOTI_JOB_CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)
          pip install moti && moti
          echo "‚úÖ Moti completed"

      - name: Keep VNC Session Alive
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          export DBUS_SESSION_BUS_ADDRESS=/dev/null
          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          CHROME_PROFILE_DIR="$HOME/chrome-botxbyte-profile"

          # 355 min = 360 min job timeout minus 5 min cleanup buffer
          END_TIME=$((SECONDS + 21300))

          while [ $SECONDS -lt $END_TIME ]; do
            REMAINING=$((END_TIME - SECONDS))
            echo "‚è±Ô∏è  Remaining: $((REMAINING/3600))h $(((REMAINING%3600)/60))m"

            # Restart VNC if crashed
            if ! pgrep -f "Xvnc.*:1" > /dev/null; then
              echo "‚ö†Ô∏è  VNC stopped ‚Äî restarting..."
              vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT
              sleep 3
              pgrep -f "Xvnc.*:1" > /dev/null && echo "‚úÖ VNC restarted" || { echo "‚ùå VNC restart failed"; exit 1; }
            fi

            # Restart cloudflared if crashed
            if [ "${{ steps.config.outputs.cloudflare_enabled }}" = "true" ] && ! pgrep -x cloudflared > /dev/null; then
              echo "‚ö†Ô∏è  Tunnel stopped ‚Äî restarting..."
              cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
              sleep 5
              pgrep -x cloudflared > /dev/null && echo "‚úÖ Tunnel restarted" || { cat /tmp/tunnel.log; exit 1; }
            fi

            # Restart BotXByte server if crashed
            if ! pgrep -f "server.py" > /dev/null; then
              echo "‚ö†Ô∏è  BotXByte server stopped ‚Äî restarting..."
              cd "$EXTENSION_DIR"
              export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
              nohup python3 server.py > /tmp/botxbyte-server.log 2>&1 &
              sleep 3
              pgrep -f "server.py" > /dev/null && echo "‚úÖ Server restarted" || cat /tmp/botxbyte-server.log
            fi

            # Restart Chrome if crashed
            if ! pgrep -f "google-chrome" > /dev/null; then
              echo "‚ö†Ô∏è  Chrome stopped ‚Äî restarting..."
              export DISPLAY=:1 NO_AT_BRIDGE=1 DBUS_SESSION_BUS_ADDRESS=/dev/null
              rm -rf "$EXTENSION_DIR/_metadata"
              google-chrome \
                --no-first-run --no-default-browser-check \
                --disable-gpu --no-sandbox --disable-dev-shm-usage \
                --enable-extensions \
                --load-extension="$EXTENSION_DIR" \
                --allow-legacy-extension-manifests \
                --user-data-dir="$CHROME_PROFILE_DIR" \
                --remote-debugging-port=9222 \
                --remote-allow-origins='*' \
                --new-window "about:blank" \
                2>/tmp/chrome-stderr.log &
              sleep 8
              pgrep -f "google-chrome" > /dev/null && echo "‚úÖ Chrome restarted" || echo "‚ö†Ô∏è Chrome failed to restart"
            fi

            sleep 30
          done
          echo "‚úÖ Session complete"

      - name: Cleanup Webshare
        if: always() && steps.config.outputs.webshare_enabled == 'true'
        run: |
          AUTH_ID="${{ steps.webshare.outputs.webshare_auth_id }}"
          [ -n "$AUTH_ID" ] && [ "$AUTH_ID" != "null" ] && \
            curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/${AUTH_ID}/" \
              -X DELETE -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}" > /dev/null && \
            echo "‚úÖ Webshare IP deregistered" || echo "‚ö†Ô∏è Nothing to deregister"

      - name: Cleanup BotXByte
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          pkill -f "google-chrome" || true
          pkill -f "server.py" || true
          echo "‚úÖ Cleanup done"

      - name: Cleanup Cloudflare
        if: always() && steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          pkill -x cloudflared || true
          sleep 2
          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          ACCT="${{ steps.config.outputs.cloudflare_account_id }}"
          ZONE="${{ steps.config.outputs.cloudflare_zone_id }}"
          TOKEN="${{ steps.config.outputs.cloudflare_api_token }}"
          TUNNEL_ID="${{ steps.tunnel.outputs.tunnel_id }}"
          USER_ID="${{ steps.config.outputs.user_id }}"
          WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
          BROWSER_PROFILE_ID="${{ steps.config.outputs.browser_profile_id }}"

          if [ -n "$FULL_HOSTNAME" ] && [ "$FULL_HOSTNAME" != "null" ]; then
            DEL_URL="http://129.212.196.173/ai-management-service/api/v1/cloudflare-tunnel-info/delete/?tunnel_url=https://${FULL_HOSTNAME}"
            [ -n "$BROWSER_PROFILE_ID" ] && [ "$BROWSER_PROFILE_ID" != "null" ] && \
              DEL_URL="${DEL_URL}&browser_profile_id=${BROWSER_PROFILE_ID}"
            curl -s "$DEL_URL" -X DELETE -H "user-id: ${USER_ID}" -H "workspace-id: ${WORKSPACE_ID}" > /dev/null

            DNS_ID=$(curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records?name=${FULL_HOSTNAME}" \
              --header "Authorization: Bearer ${TOKEN}" | jq -r '.result[0].id // empty')
            [ -n "$DNS_ID" ] && curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records/${DNS_ID}" \
              --request DELETE --header "Authorization: Bearer ${TOKEN}" | \
              jq -r 'if .success then "‚úÖ DNS deleted" else "‚ö†Ô∏è DNS delete failed" end'
          fi

          [ -n "$TUNNEL_ID" ] && [ "$TUNNEL_ID" != "null" ] && \
            curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/accounts/${ACCT}/cfd_tunnel/${TUNNEL_ID}" \
              --request DELETE --header "Authorization: Bearer ${TOKEN}" | \
            jq -r 'if .success then "‚úÖ Tunnel deleted" else "‚ö†Ô∏è Tunnel delete failed" end'

      - name: Cleanup VNC
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          vncserver -kill :1 || true
          echo "‚úÖ VNC cleaned up"
