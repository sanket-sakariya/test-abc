name: VNC Data Static Timeout
on:
  workflow_dispatch:
    inputs:
      base64_config:
        description: 'Base64 encoded JSON configuration'
        required: true
        type: string

env:
  DISPLAY: :1
  VNC_PORT: 5901
  NOVNC_PORT: 6080

jobs:
  process:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Fetch and Parse Config
        id: config
        run: |
          CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)

          VNC_ENABLED=$(echo "$CONFIG" | jq -r '.vnc_enabled // "false"')
          CLOUDFLARE_ENABLED=$(echo "$CONFIG" | jq -r '.cloudflare_enabled // "false"')
          WEBSHARE_ENABLED=$(echo "$CONFIG" | jq -r '.webshare_enabled // "false"')
          echo "vnc_enabled=$VNC_ENABLED" >> $GITHUB_OUTPUT
          echo "cloudflare_enabled=$CLOUDFLARE_ENABLED" >> $GITHUB_OUTPUT
          echo "webshare_enabled=$WEBSHARE_ENABLED" >> $GITHUB_OUTPUT

          USER_ID=$(echo "$CONFIG" | jq -r '.user_id // "69c3090b-464d-4de3-9358-ceca1c9e2aa8"')
          WORKSPACE_ID=$(echo "$CONFIG" | jq -r '.workspace_id // "ceae1caa-1538-4859-8e1a-24a8b4904d5f"')
          echo "user_id=$USER_ID" >> $GITHUB_OUTPUT
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT

          if [ "$VNC_ENABLED" = "true" ]; then
            VNC_PASSWORD=$(echo "$CONFIG" | jq -r '.vnc_password // ""')
            echo "vnc_password=$VNC_PASSWORD" >> $GITHUB_OUTPUT
          fi

          if [ "$CLOUDFLARE_ENABLED" = "true" ]; then
            CLOUDFLARE_API_TOKEN=$(echo "$CONFIG" | jq -r '.cloudflare_api_token // ""')
            CLOUDFLARE_ACCOUNT_ID=$(echo "$CONFIG" | jq -r '.cloudflare_account_id // ""')
            CLOUDFLARE_ZONE_ID=$(echo "$CONFIG" | jq -r '.cloudflare_zone_id // ""')
            HOSTNAME=$(echo "$CONFIG" | jq -r '.hostname // ""')
            BROWSER_PROFILE_ID=$(echo "$CONFIG" | jq -r '.browser_profile_id // ""')
            echo "cloudflare_api_token=$CLOUDFLARE_API_TOKEN" >> $GITHUB_OUTPUT
            echo "cloudflare_account_id=$CLOUDFLARE_ACCOUNT_ID" >> $GITHUB_OUTPUT
            echo "cloudflare_zone_id=$CLOUDFLARE_ZONE_ID" >> $GITHUB_OUTPUT
            echo "hostname=$HOSTNAME" >> $GITHUB_OUTPUT
            echo "browser_profile_id=$BROWSER_PROFILE_ID" >> $GITHUB_OUTPUT
            echo "‚úÖ Cloudflare Config Loaded"
            echo "  Hostname: $HOSTNAME"
          fi

          if [ "$WEBSHARE_ENABLED" = "true" ]; then
            WEBSHARE_API_TOKEN=$(echo "$CONFIG" | jq -r '.webshare_api_token // ""')
            echo "webshare_api_token=$WEBSHARE_API_TOKEN" >> $GITHUB_OUTPUT
            echo "‚úÖ Webshare Config Loaded"
          fi

          echo "‚úÖ Config Loaded:"
          echo "  VNC: $VNC_ENABLED"
          echo "  Cloudflare: $CLOUDFLARE_ENABLED"
          echo "  Webshare: $WEBSHARE_ENABLED"
          echo "  User ID: $USER_ID"
          echo "  Workspace ID: $WORKSPACE_ID"

      - name: Register IP with Webshare
        if: steps.config.outputs.webshare_enabled == 'true'
        id: webshare
        run: |
          echo "Registering IP with Webshare..."
          PUBLIC_IP=$(curl -s 'https://api.ipify.org?format=json' | jq -r '.ip')
          echo "Public IP: $PUBLIC_IP"

          RESPONSE=$(curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/" \
            -X POST \
            -d "{\"ip_address\": \"$PUBLIC_IP\"}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}")

          AUTH_ID=$(echo "$RESPONSE" | jq -r '.id // empty')

          if [ -n "$AUTH_ID" ]; then
            echo "webshare_auth_id=$AUTH_ID" >> $GITHUB_OUTPUT
            echo "‚úÖ IP registered with Webshare (Auth ID: $AUTH_ID)"
          else
            echo "‚ö†Ô∏è Failed to register IP with Webshare"
            echo "$RESPONSE" | jq '.'
          fi

      - name: Install Desktop Environment
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing XFCE desktop environment..."
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            xfce4 \
            xfce4-goodies \
            xfce4-terminal \
            firefox \
            dbus-x11 \
            dbus-user-session \
            x11-utils \
            x11-apps \
            x11-common \
            x11-session-utils \
            x11-xserver-utils \
            xfonts-base \
            xfonts-100dpi \
            xfonts-75dpi \
            xfonts-cyrillic \
            xubuntu-icon-theme \
            xubuntu-wallpapers \
            gnome-icon-theme

      - name: Install Google Chrome
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing Google Chrome..."
          wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
          sudo dpkg -i google-chrome-stable_current_amd64.deb || sudo apt-get install -f -y
          rm google-chrome-stable_current_amd64.deb
          google-chrome --version
          echo "‚úÖ Google Chrome installed"

      - name: Install TurboVNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing TurboVNC server..."
          wget -q https://phoenixnap.dl.sourceforge.net/project/turbovnc/2.2.5/turbovnc_2.2.5_amd64.deb
          sudo dpkg -i turbovnc_2.2.5_amd64.deb
          rm turbovnc_2.2.5_amd64.deb

      - name: Install noVNC (Web VNC)
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing noVNC for web-based access..."
          cd ~
          git clone https://github.com/novnc/noVNC.git
          cd noVNC
          git clone https://github.com/novnc/websockify.git

      - name: Configure VNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          mkdir -p ~/.vnc

          echo "${{ steps.config.outputs.vnc_password }}" | vncpasswd -f > ~/.vnc/passwd
          chmod 600 ~/.vnc/passwd

          cat > ~/.vnc/xstartup.turbovnc << 'EOF'
          #!/bin/bash
          export NO_AT_BRIDGE=1
          export SESSION_MANAGER=""
          dbus-launch /usr/bin/startxfce4 &
          EOF
          chmod +x ~/.vnc/xstartup.turbovnc

      - name: Start VNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          echo "Starting TurboVNC server on display :1..."

          vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT 2>&1 | tee /tmp/vnc-start.log
          sleep 8

          if pgrep -f "Xvnc.*:1" > /dev/null; then
            echo "‚úÖ TurboVNC Server started on port $VNC_PORT"
          else
            echo "‚ùå Failed to start VNC server"
            cat /tmp/vnc-start.log
            exit 1
          fi

      - name: Install websockify dependency
        if: steps.config.outputs.vnc_enabled == 'true'
        run: pip install numpy websocket-client

      - name: Start noVNC (Web VNC)
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Starting noVNC web server..."
          cd ~/noVNC

          if [ ! -f ./utils/websockify/run ]; then
            cd utils && git clone https://github.com/novnc/websockify.git && cd ..
          fi

          ./utils/novnc_proxy --vnc localhost:$VNC_PORT --listen $NOVNC_PORT &
          NOVNC_PID=$!
          sleep 5

          if ss -tuln | grep -q ":$NOVNC_PORT "; then
            echo "‚úÖ noVNC started on port $NOVNC_PORT (PID: $NOVNC_PID)"
          else
            if kill -0 $NOVNC_PID 2>/dev/null; then
              echo "‚úÖ noVNC process running (PID: $NOVNC_PID)"
              sleep 3
            else
              echo "‚ùå noVNC failed to start"
              exit 1
            fi
          fi

      - name: Download and Setup BotXByte Extension
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Downloading BotXByte extension..."
          EXTENSION_DIR="$HOME/real-botxbyte-extension"

          wget -q -O /tmp/real-botxbyte-extension.zip "https://github.com/user-attachments/files/25434674/real-botxbyte-extension.zip"

          TEMP_EXTRACT="/tmp/extension-extract"
          rm -rf "$TEMP_EXTRACT"
          mkdir -p "$TEMP_EXTRACT"
          unzip -o /tmp/real-botxbyte-extension.zip -d "$TEMP_EXTRACT"
          rm /tmp/real-botxbyte-extension.zip

          MANIFEST_PATH=$(find "$TEMP_EXTRACT" -name "manifest.json" -type f | head -1)
          if [ -z "$MANIFEST_PATH" ]; then
            echo "‚ùå manifest.json not found in extracted zip!"
            exit 1
          fi

          ACTUAL_EXT_DIR=$(dirname "$MANIFEST_PATH")
          rm -rf "$EXTENSION_DIR"
          mv "$ACTUAL_EXT_DIR" "$EXTENSION_DIR"
          rm -rf "$TEMP_EXTRACT"

          # Remove stale metadata and junk files
          rm -rf "$EXTENSION_DIR/_metadata"
          rm -rf "$EXTENSION_DIR/.git"
          rm -f "$EXTENSION_DIR/.gitignore" "$EXTENSION_DIR/.env.dev" "$EXTENSION_DIR/README.md" "$EXTENSION_DIR/llm.txt"

          if [ ! -f "$EXTENSION_DIR/manifest.json" ]; then
            echo "‚ùå manifest.json not found after setup"
            exit 1
          fi

          # Install Python dependencies
          if [ -f "$EXTENSION_DIR/requirements.txt" ]; then
            pip install -r "$EXTENSION_DIR/requirements.txt"
          fi

          echo "‚úÖ BotXByte Extension setup complete"
          echo "  Extension path: $EXTENSION_DIR"
          cat "$EXTENSION_DIR/manifest.json"

      - name: Start BotXByte Server
        if: steps.config.outputs.vnc_enabled == 'true'
        id: botxbyte_server
        run: |
          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"

          cd "$EXTENSION_DIR"
          nohup python3 server.py > /tmp/botxbyte-server.log 2>&1 &
          SERVER_PID=$!
          echo "server_pid=$SERVER_PID" >> $GITHUB_OUTPUT
          sleep 3

          if kill -0 $SERVER_PID 2>/dev/null; then
            echo "‚úÖ BotXByte server started (PID: $SERVER_PID)"
          else
            echo "‚ùå BotXByte server failed to start"
            cat /tmp/botxbyte-server.log
            exit 1
          fi

      # ============================================================
      # FIX: Use a single-launch approach with --load-extension
      # BYPASS the broken 3-phase CDP dev-mode approach entirely.
      #
      # Root cause of old failure:
      #   1. Phase 2 enables dev mode via CDP ‚Üí Chrome writes HMAC
      #   2. You then WRITE to Preferences (exited_cleanly patch)
      #      ‚Üí this INVALIDATES the HMAC Chrome stored
      #   3. Phase 3 relaunches ‚Üí Chrome detects HMAC mismatch
      #      ‚Üí silently drops the extension / resets dev mode
      #
      # Fix: Set the Chrome policy to allow unpacked extensions,
      # set dev mode via JSON preferences BEFORE first launch,
      # then launch once with --load-extension.
      # Chrome writes the HMAC on first launch itself ‚Äî no patching.
      # ============================================================
      - name: Launch Chrome with BotXByte Extension
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export DISPLAY=:1
          export NO_AT_BRIDGE=1
          export DBUS_SESSION_BUS_ADDRESS=/dev/null

          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          CHROME_PROFILE_DIR="$HOME/chrome-botxbyte-profile"

          rm -rf "$CHROME_PROFILE_DIR"
          mkdir -p "$CHROME_PROFILE_DIR/Default"

          if [ ! -f "$EXTENSION_DIR/manifest.json" ]; then
            echo "‚ùå Extension manifest.json not found"
            exit 1
          fi

          rm -rf "$EXTENSION_DIR/_metadata"

          # ----------------------------------------------------------
          # STEP 1: Write Chrome policy to allow unpacked/dev extensions
          # This is the most reliable way ‚Äî policy overrides HMAC checks
          # ----------------------------------------------------------
          sudo mkdir -p /etc/opt/chrome/policies/managed
          cat << 'POLICY' | sudo tee /etc/opt/chrome/policies/managed/allow_dev_extensions.json > /dev/null
          {
            "ExtensionSettings": {
              "*": { "installation_mode": "allowed" }
            },
            "DeveloperToolsAvailability": 1,
            "ExtensionDeveloperModeAllowed": true,
            "BlockExternalExtensions": false
          }
          POLICY

          # ----------------------------------------------------------
          # STEP 2: Pre-write Preferences with dev mode ON and
          # extensions already in the allowed list BEFORE Chrome starts.
          # Chrome will read this, validate it (since profile is fresh),
          # and write correct HMACs on first launch.
          # ----------------------------------------------------------
          EXT_ID=$(python3 -c "
          import hashlib, json, os
          # Derive extension ID from its path (same algorithm Chrome uses for unpacked)
          path = os.path.realpath('$EXTENSION_DIR')
          h = hashlib.md5(path.encode()).hexdigest()[:32]
          # Chrome uses a-p encoding (0=a, 1=b, ..., 9=j, a=k, ..., f=p)
          result = ''
          for c in h:
              n = int(c, 16)
              result += chr(ord('a') + n)
          print(result)
          ")
          echo "  Derived Extension ID: $EXT_ID"

          # Pre-seed Preferences to enable developer mode
          # This is written BEFORE Chrome launches so Chrome computes
          # the HMAC itself ‚Äî NOT after-the-fact patching
          cat > "$CHROME_PROFILE_DIR/Default/Preferences" << PREFS_EOF
          {
            "extensions": {
              "ui": {
                "developer_mode": true
              },
              "alerts": {
                "initialized": true
              }
            },
            "profile": {
              "exit_type": "Normal",
              "exited_cleanly": true,
              "content_settings": {}
            },
            "browser": {
              "has_seen_welcome_page": true,
              "show_home_button": false
            }
          }
          PREFS_EOF

          touch "$CHROME_PROFILE_DIR/First Run"

          # ----------------------------------------------------------
          # STEP 3: Single launch with --load-extension
          # Chrome loads the profile, sees developer_mode=true in
          # Preferences (written above), loads the extension,
          # then re-computes and saves correct HMACs.
          # No kill/relaunch cycle = no HMAC invalidation.
          # ----------------------------------------------------------
          echo "Launching Chrome with extension (single launch)..."
          google-chrome \
            --no-first-run \
            --no-default-browser-check \
            --disable-gpu \
            --no-sandbox \
            --disable-dev-shm-usage \
            --enable-extensions \
            --load-extension="$EXTENSION_DIR" \
            --user-data-dir="$CHROME_PROFILE_DIR" \
            --remote-debugging-port=9222 \
            --new-window \
            "chrome://extensions" \
            2>/tmp/chrome-stderr.log &

          CHROME_PID=$!
          echo "  Chrome PID: $CHROME_PID"
          sleep 15

          if ! pgrep -f "google-chrome" > /dev/null; then
            echo "‚ùå Chrome failed to launch"
            cat /tmp/chrome-stderr.log
            exit 1
          fi
          echo "‚úÖ Chrome is running"

          # ----------------------------------------------------------
          # STEP 4: Verify extension is loaded via CDP
          # ----------------------------------------------------------
          python3 << 'PYEOF'
          import websocket, json, time, urllib.request

          def cdp_http(path):
              try:
                  resp = urllib.request.urlopen(f"http://localhost:9222{path}", timeout=10)
                  return json.loads(resp.read())
              except Exception as e:
                  print(f"  CDP HTTP error: {e}")
                  return None

          def cdp_send(ws, method, params=None, msg_id=1):
              msg = {"id": msg_id, "method": method}
              if params:
                  msg["params"] = params
              ws.send(json.dumps(msg))
              while True:
                  resp = json.loads(ws.recv())
                  if resp.get("id") == msg_id:
                      return resp

          time.sleep(3)
          targets = cdp_http("/json/list") or []
          print(f"  Chrome targets: {len(targets)}")

          # Check for service workers (extension background)
          sw_targets = []
          for t in targets:
              ttype = t.get("type", "")
              url = t.get("url", "")
              if ttype == "service_worker":
                  sw_targets.append(t)
                  print(f"  ‚úÖ Service worker: {url}")
              elif "extension" in url.lower() and ttype != "page":
                  print(f"  [{ttype}] {url}")

          if not sw_targets:
              print("  ‚ö†Ô∏è  No service worker found ‚Äî extension may not have loaded")
              print("  Checking chrome://extensions page for details...")

          # Connect to extensions page and verify
          ext_tab = next((t for t in targets if "chrome://extensions" in t.get("url","")), None)
          if ext_tab and ext_tab.get("webSocketDebuggerUrl"):
              try:
                  ws = websocket.create_connection(ext_tab["webSocketDebuggerUrl"], timeout=15)
                  time.sleep(2)

                  result = cdp_send(ws, "Runtime.evaluate", {
                      "expression": """
                      (function() {
                          const manager = document.querySelector('extensions-manager');
                          if (!manager || !manager.shadowRoot) return JSON.stringify({error: 'no manager'});
                          const toolbar = manager.shadowRoot.querySelector('extensions-toolbar');
                          const devMode = toolbar?.shadowRoot?.querySelector('#devMode')?.checked || false;
                          const items = Array.from(manager.shadowRoot.querySelectorAll('extensions-item'));
                          const exts = items.map(item => {
                              const sr = item.shadowRoot;
                              return {
                                  name: sr?.querySelector('#name')?.textContent?.trim() || 'unknown',
                                  id: item.getAttribute('id') || 'unknown',
                                  enabled: !sr?.querySelector('.enable-toggle')?.hasAttribute('disabled')
                              };
                          });
                          return JSON.stringify({devMode, extensions: exts});
                      })()
                      """
                  })

                  val = result.get("result", {}).get("result", {}).get("value", "{}")
                  data = json.loads(val)
                  print(f"  Developer mode: {'ON ‚úÖ' if data.get('devMode') else 'OFF ‚ö†Ô∏è'}")
                  exts = data.get("extensions", [])
                  print(f"  Loaded extensions: {len(exts)}")
                  for e in exts:
                      status = "‚úÖ" if e.get("enabled") else "‚ö†Ô∏è disabled"
                      print(f"    {status} {e.get('name')} (ID: {e.get('id')})")

                  if not exts:
                      print("  ‚ùå No extensions visible on chrome://extensions")
                      print("  This means --load-extension was rejected by Chrome.")
                      print("  Check /tmp/chrome-stderr.log for clues.")

                  ws.close()
              except Exception as e:
                  print(f"  CDP connect error: {e}")

          version = cdp_http("/json/version") or {}
          print(f"  Chrome version: {version.get('Browser', '?')}")
          PYEOF

          if pgrep -f "server.py" > /dev/null; then
            echo "‚úÖ BotXByte server is running"
          else
            echo "‚ö†Ô∏è BotXByte server is NOT running"
            cat /tmp/botxbyte-server.log 2>/dev/null || true
          fi

          echo "‚úÖ Chrome launch complete"

      - name: Install cloudflared
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          cloudflared --version

      - name: Create Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        id: tunnel
        run: |
          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel" \
            --request POST \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data '{"name": "github-vnc-'"$(date +%s)"'", "config_src": "cloudflare"}')

          SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false')
          if [ "$SUCCESS" != "true" ]; then
            echo "‚ùå Failed to create tunnel"
            echo "$RESPONSE" | jq '.'
            exit 1
          fi

          TUNNEL_ID=$(echo "$RESPONSE" | jq -r '.result.id')
          TUNNEL_TOKEN=$(echo "$RESPONSE" | jq -r '.result.token')
          echo "tunnel_id=$TUNNEL_ID" >> $GITHUB_OUTPUT
          echo "tunnel_token=$TUNNEL_TOKEN" >> $GITHUB_OUTPUT
          echo "‚úÖ Tunnel created: $TUNNEL_ID"

      - name: Configure Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel/${{ steps.tunnel.outputs.tunnel_id }}/configurations" \
            --request PUT \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data "{
              \"config\": {
                \"ingress\": [
                  {\"hostname\": \"${{ steps.config.outputs.hostname }}\", \"path\": \"/vnc/*\", \"service\": \"http://localhost:${NOVNC_PORT}\", \"originRequest\": {}},
                  {\"hostname\": \"${{ steps.config.outputs.hostname }}\", \"path\": \"/browser-agent-management-service/*\", \"service\": \"http://localhost:8801\", \"originRequest\": {}},
                  {\"hostname\": \"${{ steps.config.outputs.hostname }}\", \"service\": \"http://localhost:${NOVNC_PORT}\", \"originRequest\": {}},
                  {\"service\": \"http_status:404\"}
                ]
              }
            }")

          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          [ "$SUCCESS" = "true" ] && echo "‚úÖ Tunnel configured" || { echo "‚ùå Failed to configure tunnel"; echo "$RESPONSE" | jq '.'; exit 1; }

      - name: Create DNS Record
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"

          EXISTING=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records?name=${FULL_HOSTNAME}" \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" | jq -r '.result[0].id // empty')

          if [ -n "$EXISTING" ]; then
            echo "Deleting existing DNS record $EXISTING..."
            curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records/${EXISTING}" \
              --request DELETE \
              --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" > /dev/null
            sleep 2
          fi

          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records" \
            --request POST \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data "{\"type\": \"CNAME\", \"proxied\": true, \"name\": \"${FULL_HOSTNAME}\", \"content\": \"${{ steps.tunnel.outputs.tunnel_id }}.cfargotunnel.com\"}")

          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          [ "$SUCCESS" = "true" ] && echo "‚úÖ DNS record created" || { echo "‚ùå Failed to create DNS record"; echo "$RESPONSE" | jq '.errors'; exit 1; }

      - name: Start Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
          sleep 10

          pgrep -x cloudflared > /dev/null && echo "‚úÖ Cloudflare Tunnel started" || { echo "‚ùå Tunnel failed"; cat /tmp/tunnel.log; exit 1; }

      - name: Display VNC Connection Info
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë          üéâ UBUNTU DESKTOP VNC IS NOW RUNNING! üéâ            ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "üåê Access URL: https://${{ steps.config.outputs.hostname }}/vnc.html"
          echo "üîå BotXByte Extension: Loaded in Chrome"
          echo "   WebSocket: ws://localhost:8765"
          echo "   HTTP API:  http://localhost:8766"

      - name: Run Moti on Desktop
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export DISPLAY=:1
          export NO_AT_BRIDGE=1
          export SESSION_MANAGER=""
          export DBUS_SESSION_BUS_ADDRESS=/dev/null
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ffmpeg libavcodec-dev libavformat-dev libavdevice-dev libavutil-dev libavfilter-dev libswscale-dev libswresample-dev pkg-config

          xfce4-terminal --maximize --title="Moti Process" \
            --command="bash -c 'export MOTI_JOB_CONFIG=\$(echo \"${{ inputs.base64_config }}\" | base64 -d) && pip install av --upgrade && pip install moti && moti; echo \"Moti completed. Press Enter to close...\"; read'" 2>/dev/null &

          sleep 5
          pgrep -f "xfce4-terminal" > /dev/null && echo "‚úÖ Moti started in desktop terminal" || echo "‚ö†Ô∏è Terminal may not have started"

      - name: Run Moti in Normal Terminal
        if: steps.config.outputs.vnc_enabled == 'false'
        timeout-minutes: 30
        run: |
          export MOTI_JOB_CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)
          pip install moti
          moti
          echo "‚úÖ Moti completed"

      # ============================================================
      # FIX: Extended monitoring loop ‚Äî was 1800s (30 min),
      # now 21600s (360 min) to match the job timeout-minutes: 360.
      # Also: Chrome restart now uses --load-extension correctly.
      # ============================================================
      - name: Keep VNC Session Alive
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          export DBUS_SESSION_BUS_ADDRESS=/dev/null
          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          CHROME_PROFILE_DIR="$HOME/chrome-botxbyte-profile"

          echo "Keeping VNC session alive for up to 360 minutes..."

          # Match the job timeout (360 minutes = 21600 seconds, leave 5 min buffer)
          END_TIME=$((SECONDS + 21300))

          while [ $SECONDS -lt $END_TIME ]; do
            REMAINING=$((END_TIME - SECONDS))
            HOURS=$((REMAINING / 3600))
            MINUTES=$(((REMAINING % 3600) / 60))

            if [ "${{ steps.config.outputs.cloudflare_enabled }}" = "true" ]; then
              echo "‚è±Ô∏è Remaining: ${HOURS}h ${MINUTES}m | Access: https://${{ steps.config.outputs.hostname }}/vnc.html"
            else
              echo "‚è±Ô∏è Remaining: ${HOURS}h ${MINUTES}m | VNC running locally"
            fi

            # Restart VNC if needed
            if ! pgrep -f "Xvnc.*:1" > /dev/null; then
              echo "‚ùå VNC stopped! Restarting..."
              vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT
              sleep 3
              pgrep -f "Xvnc.*:1" > /dev/null && echo "‚úÖ VNC restarted" || { echo "‚ùå VNC restart failed"; exit 1; }
            fi

            # Restart cloudflared if needed
            if [ "${{ steps.config.outputs.cloudflare_enabled }}" = "true" ]; then
              if ! pgrep -x "cloudflared" > /dev/null; then
                echo "‚ùå Tunnel stopped! Restarting..."
                cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
                sleep 5
                pgrep -x "cloudflared" > /dev/null && echo "‚úÖ Tunnel restarted" || { echo "‚ùå Tunnel restart failed"; cat /tmp/tunnel.log; exit 1; }
              fi
            fi

            # Restart BotXByte server if needed
            if ! kill -0 ${{ steps.botxbyte_server.outputs.server_pid }} 2>/dev/null && ! pgrep -f "server.py" > /dev/null; then
              echo "‚ùå BotXByte server stopped! Restarting..."
              cd "$EXTENSION_DIR"
              export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
              nohup python3 server.py > /tmp/botxbyte-server.log 2>&1 &
              sleep 3
              pgrep -f "server.py" > /dev/null && echo "‚úÖ BotXByte server restarted" || { echo "‚ö†Ô∏è BotXByte server failed to restart"; cat /tmp/botxbyte-server.log; }
            fi

            # Restart Chrome if needed ‚Äî use same single-launch approach
            if ! pgrep -f "google-chrome" > /dev/null; then
              echo "‚ùå Chrome stopped! Restarting..."
              export DISPLAY=:1
              export NO_AT_BRIDGE=1
              export DBUS_SESSION_BUS_ADDRESS=/dev/null

              # Remove stale _metadata before relaunch
              rm -rf "$EXTENSION_DIR/_metadata"

              google-chrome \
                --no-first-run \
                --no-default-browser-check \
                --disable-gpu \
                --no-sandbox \
                --disable-dev-shm-usage \
                --enable-extensions \
                --load-extension="$EXTENSION_DIR" \
                --user-data-dir="$CHROME_PROFILE_DIR" \
                --remote-debugging-port=9222 \
                --new-window \
                "chrome://extensions" \
                2>/tmp/chrome-stderr.log &
              sleep 8
              pgrep -f "google-chrome" > /dev/null && echo "‚úÖ Chrome restarted with BotXByte extension" || echo "‚ö†Ô∏è Chrome failed to restart"
            fi

            sleep 30
          done

          echo "‚úÖ Session time complete"

      - name: Cleanup Webshare IP Authorization
        if: always() && steps.config.outputs.webshare_enabled == 'true'
        run: |
          if [ -n "${{ steps.webshare.outputs.webshare_auth_id }}" ] && [ "${{ steps.webshare.outputs.webshare_auth_id }}" != "null" ]; then
            DELETE_RESPONSE=$(curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/${{ steps.webshare.outputs.webshare_auth_id }}/" \
              -X DELETE \
              -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}")
            [ -z "$DELETE_RESPONSE" ] || [ "$DELETE_RESPONSE" = "{}" ] && echo "‚úÖ IP authorization removed" || echo "‚ö†Ô∏è Failed to remove IP: $DELETE_RESPONSE"
          else
            echo "‚ö†Ô∏è No Webshare auth ID to delete"
          fi

      - name: Cleanup BotXByte Server
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          pkill -f "google-chrome" || true
          pkill -f "server.py" || true
          sleep 2
          echo "‚úÖ BotXByte cleanup complete"

      - name: Cleanup Cloudflare Tunnel and DNS
        if: always() && steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          pkill -x cloudflared || true
          sleep 2

          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          USER_ID="${{ steps.config.outputs.user_id }}"
          WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
          BROWSER_PROFILE_ID="${{ steps.config.outputs.browser_profile_id }}"

          if [ -n "$FULL_HOSTNAME" ] && [ "$FULL_HOSTNAME" != "null" ]; then
            DELETE_URL="http://129.212.196.173/ai-management-service/api/v1/cloudflare-tunnel-info/delete/?tunnel_url=https://${FULL_HOSTNAME}"
            [ -n "$BROWSER_PROFILE_ID" ] && [ "$BROWSER_PROFILE_ID" != "null" ] && DELETE_URL="${DELETE_URL}&browser_profile_id=${BROWSER_PROFILE_ID}"
            curl -s "$DELETE_URL" -X DELETE -H "user-id: ${USER_ID}" -H "workspace-id: ${WORKSPACE_ID}"

            EXISTING_DNS=$(curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records?name=${FULL_HOSTNAME}" \
              --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" | jq -r '.result[0].id // empty')

            if [ -n "$EXISTING_DNS" ]; then
              DELETE_RESPONSE=$(curl -s -A "Mozilla/5.0" \
                "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records/${EXISTING_DNS}" \
                --request DELETE \
                --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}")
              echo "$DELETE_RESPONSE" | jq -r '.success' | grep -q true && echo "‚úÖ DNS deleted" || echo "‚ö†Ô∏è DNS delete failed"
            fi
          fi

          if [ -n "${{ steps.tunnel.outputs.tunnel_id }}" ] && [ "${{ steps.tunnel.outputs.tunnel_id }}" != "null" ]; then
            TUNNEL_DELETE=$(curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel/${{ steps.tunnel.outputs.tunnel_id }}" \
              --request DELETE \
              --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}")
            echo "$TUNNEL_DELETE" | jq -r '.success' | grep -q true && echo "‚úÖ Tunnel deleted" || echo "‚ö†Ô∏è Tunnel delete failed"
          fi

          echo "‚úÖ Cloudflare cleanup complete"

      - name: Cleanup VNC
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          vncserver -kill :1 || true
          echo "‚úÖ VNC cleanup complete"
