name: VNC Data Static Timeout
on:
  workflow_dispatch:
    inputs:
      base64_config:
        description: 'Base64 encoded JSON configuration'
        required: true
        type: string

env:
  DISPLAY: :1
  VNC_PORT: 5901
  NOVNC_PORT: 6080

jobs:
  process:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Fetch and Parse Config
        id: config
        run: |
          # Decode base64 config (without echoing it)
          CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)

          # Parse VNC, Cloudflare, and Webshare values (lowercase keys)
          VNC_ENABLED=$(echo "$CONFIG" | jq -r '.vnc_enabled // "false"')
          CLOUDFLARE_ENABLED=$(echo "$CONFIG" | jq -r '.cloudflare_enabled // "false"')
          WEBSHARE_ENABLED=$(echo "$CONFIG" | jq -r '.webshare_enabled // "false"')
          echo "vnc_enabled=$VNC_ENABLED" >> $GITHUB_OUTPUT
          echo "cloudflare_enabled=$CLOUDFLARE_ENABLED" >> $GITHUB_OUTPUT
          echo "webshare_enabled=$WEBSHARE_ENABLED" >> $GITHUB_OUTPUT

          # Parse user_id and workspace_id with defaults
          USER_ID=$(echo "$CONFIG" | jq -r '.user_id // "69c3090b-464d-4de3-9358-ceca1c9e2aa8"')
          WORKSPACE_ID=$(echo "$CONFIG" | jq -r '.workspace_id // "ceae1caa-1538-4859-8e1a-24a8b4904d5f"')
          echo "user_id=$USER_ID" >> $GITHUB_OUTPUT
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT

          # Parse VNC password if VNC is enabled
          if [ "$VNC_ENABLED" = "true" ]; then
            VNC_PASSWORD=$(echo "$CONFIG" | jq -r '.vnc_password // ""')
            echo "vnc_password=$VNC_PASSWORD" >> $GITHUB_OUTPUT
          fi

          # Parse Cloudflare-related values if Cloudflare is enabled
          if [ "$CLOUDFLARE_ENABLED" = "true" ]; then
            CLOUDFLARE_API_TOKEN=$(echo "$CONFIG" | jq -r '.cloudflare_api_token // ""')
            CLOUDFLARE_ACCOUNT_ID=$(echo "$CONFIG" | jq -r '.cloudflare_account_id // ""')
            CLOUDFLARE_ZONE_ID=$(echo "$CONFIG" | jq -r '.cloudflare_zone_id // ""')
            HOSTNAME=$(echo "$CONFIG" | jq -r '.hostname // ""')
            BROWSER_PROFILE_ID=$(echo "$CONFIG" | jq -r '.browser_profile_id // ""')

            echo "cloudflare_api_token=$CLOUDFLARE_API_TOKEN" >> $GITHUB_OUTPUT
            echo "cloudflare_account_id=$CLOUDFLARE_ACCOUNT_ID" >> $GITHUB_OUTPUT
            echo "cloudflare_zone_id=$CLOUDFLARE_ZONE_ID" >> $GITHUB_OUTPUT
            echo "hostname=$HOSTNAME" >> $GITHUB_OUTPUT
            echo "browser_profile_id=$BROWSER_PROFILE_ID" >> $GITHUB_OUTPUT

            echo "‚úÖ Cloudflare Config Loaded"
            echo "  Hostname: $HOSTNAME"
          fi

          # Parse Webshare-related values if Webshare is enabled
          if [ "$WEBSHARE_ENABLED" = "true" ]; then
            WEBSHARE_API_TOKEN=$(echo "$CONFIG" | jq -r '.webshare_api_token // ""')
            echo "webshare_api_token=$WEBSHARE_API_TOKEN" >> $GITHUB_OUTPUT

            echo "‚úÖ Webshare Config Loaded"
          fi

          echo "‚úÖ Config Loaded:"
          echo "  VNC: $VNC_ENABLED"
          echo "  Cloudflare: $CLOUDFLARE_ENABLED"
          echo "  Webshare: $WEBSHARE_ENABLED"
          echo "  User ID: $USER_ID"
          echo "  Workspace ID: $WORKSPACE_ID"

      - name: Register IP with Webshare
        if: steps.config.outputs.webshare_enabled == 'true'
        id: webshare
        run: |
          echo "Registering IP with Webshare..."

          # Get current public IP
          PUBLIC_IP=$(curl -s 'https://api.ipify.org?format=json' | jq -r '.ip')
          echo "Public IP: $PUBLIC_IP"

          # Register IP with Webshare
          RESPONSE=$(curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/" \
            -X POST \
            -d "{\"ip_address\": \"$PUBLIC_IP\"}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}")

          # Extract authorization ID
          AUTH_ID=$(echo "$RESPONSE" | jq -r '.id // empty')

          if [ -n "$AUTH_ID" ]; then
            echo "webshare_auth_id=$AUTH_ID" >> $GITHUB_OUTPUT
            echo "‚úÖ IP registered with Webshare (Auth ID: $AUTH_ID)"
          else
            echo "‚ö†Ô∏è Failed to register IP with Webshare"
            echo "$RESPONSE" | jq '.'
          fi

      - name: Install Desktop Environment
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing XFCE desktop environment..."
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            xfce4 \
            xfce4-goodies \
            xfce4-terminal \
            firefox \
            dbus-x11 \
            dbus-user-session \
            x11-utils \
            x11-apps \
            x11-common \
            x11-session-utils \
            x11-xserver-utils \
            xfonts-base \
            xfonts-100dpi \
            xfonts-75dpi \
            xfonts-cyrillic \
            xubuntu-icon-theme \
            xubuntu-wallpapers \
            gnome-icon-theme

      - name: Install Google Chrome
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing Google Chrome..."
          wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
          sudo dpkg -i google-chrome-stable_current_amd64.deb || sudo apt-get install -f -y
          rm google-chrome-stable_current_amd64.deb
          google-chrome --version
          echo "‚úÖ Google Chrome installed"

      - name: Install TurboVNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing TurboVNC server..."
          wget -q https://phoenixnap.dl.sourceforge.net/project/turbovnc/2.2.5/turbovnc_2.2.5_amd64.deb
          sudo dpkg -i turbovnc_2.2.5_amd64.deb
          rm turbovnc_2.2.5_amd64.deb

      - name: Install noVNC (Web VNC)
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Installing noVNC for web-based access..."
          cd ~
          git clone https://github.com/novnc/noVNC.git
          cd noVNC
          git clone https://github.com/novnc/websockify.git

      - name: Configure VNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          mkdir -p ~/.vnc

          # Create password file
          echo "${{ steps.config.outputs.vnc_password }}" | vncpasswd -f > ~/.vnc/passwd
          chmod 600 ~/.vnc/passwd

          # Create xstartup script
          cat > ~/.vnc/xstartup.turbovnc << 'EOF'
          #!/bin/bash
          # Suppress accessibility warnings
          export NO_AT_BRIDGE=1
          export SESSION_MANAGER=""

          # Start XFCE desktop
          dbus-launch /usr/bin/startxfce4 &
          EOF

          chmod +x ~/.vnc/xstartup.turbovnc

      - name: Start VNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          echo "Starting TurboVNC server on display :1..."

          vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT 2>&1 | tee /tmp/vnc-start.log
          sleep 8

          if pgrep -f "Xvnc.*:1" > /dev/null; then
            echo "‚úÖ TurboVNC Server started successfully on port $VNC_PORT"
            ps aux | grep Xvnc | grep -v grep
          else
            echo "‚ùå Failed to start VNC server"
            cat /tmp/vnc-start.log
            exit 1
          fi

      - name: Install websockify dependency
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          pip install numpy
          echo "‚úÖ numpy installed (speeds up websockify HyBi protocol)"

      - name: Start noVNC (Web VNC)
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Starting noVNC web server..."
          cd ~/noVNC

          # Ensure websockify is properly installed
          if [ ! -f ./utils/websockify/run ]; then
            echo "websockify not found, cloning..."
            cd utils
            git clone https://github.com/novnc/websockify.git
            cd ..
          fi

          ./utils/novnc_proxy --vnc localhost:$VNC_PORT --listen $NOVNC_PORT &
          NOVNC_PID=$!
          sleep 5

          # Use ss instead of netstat (netstat not available on ubuntu runners)
          if ss -tuln | grep -q ":$NOVNC_PORT "; then
            echo "‚úÖ noVNC started successfully on port $NOVNC_PORT (PID: $NOVNC_PID)"
          else
            # Fallback: check if the process is still running
            if kill -0 $NOVNC_PID 2>/dev/null; then
              echo "‚úÖ noVNC process is running (PID: $NOVNC_PID), port may still be binding..."
              sleep 3
            else
              echo "‚ùå noVNC failed to start"
              exit 1
            fi
          fi

      - name: Download and Setup BotXByte Extension
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Downloading BotXByte extension..."

          EXTENSION_DIR="$HOME/real-botxbyte-extension"

          # Download the extension zip from GitHub
          wget -q -O /tmp/real-botxbyte-extension.zip "https://github.com/user-attachments/files/25434674/real-botxbyte-extension.zip"

          # Extract to a temp location first to handle nested directories
          TEMP_EXTRACT="/tmp/extension-extract"
          rm -rf "$TEMP_EXTRACT"
          mkdir -p "$TEMP_EXTRACT"
          unzip -o /tmp/real-botxbyte-extension.zip -d "$TEMP_EXTRACT"
          rm /tmp/real-botxbyte-extension.zip

          # Debug: show what was extracted
          echo "Extracted contents:"
          find "$TEMP_EXTRACT" -maxdepth 3 -type f | head -20

          # Find where manifest.json actually is (handles nested directory from zip)
          MANIFEST_PATH=$(find "$TEMP_EXTRACT" -name "manifest.json" -type f | head -1)

          if [ -z "$MANIFEST_PATH" ]; then
            echo "‚ùå manifest.json not found in extracted zip!"
            find "$TEMP_EXTRACT" -type f
            exit 1
          fi

          ACTUAL_EXT_DIR=$(dirname "$MANIFEST_PATH")
          echo "Found manifest.json at: $MANIFEST_PATH"
          echo "Extension root: $ACTUAL_EXT_DIR"

          # Move the actual extension directory to the expected location
          rm -rf "$EXTENSION_DIR"
          mv "$ACTUAL_EXT_DIR" "$EXTENSION_DIR"
          rm -rf "$TEMP_EXTRACT"

          # --- CRITICAL: Remove _metadata directory ---
          # Chrome generates _metadata/generated_indexed_rulesets for declarativeNetRequest.
          # A stale pre-compiled _metadata from a different Chrome version causes Chrome
          # to SILENTLY REFUSE to load the extension. Chrome must regenerate it itself.
          if [ -d "$EXTENSION_DIR/_metadata" ]; then
            echo "Removing stale _metadata directory (Chrome will regenerate it)..."
            rm -rf "$EXTENSION_DIR/_metadata"
          fi

          # Remove .git directory - not part of the extension, wastes space,
          # and Chrome scans all files in the extension directory
          if [ -d "$EXTENSION_DIR/.git" ]; then
            echo "Removing .git directory (not needed for extension)..."
            rm -rf "$EXTENSION_DIR/.git"
          fi

          # Remove other non-extension files
          rm -f "$EXTENSION_DIR/.gitignore" "$EXTENSION_DIR/.env.dev" "$EXTENSION_DIR/README.md" "$EXTENSION_DIR/llm.txt"

          # Verify the extension structure
          echo "Extension directory contents (cleaned):"
          ls -la "$EXTENSION_DIR/"

          if [ ! -f "$EXTENSION_DIR/manifest.json" ]; then
            echo "‚ùå manifest.json not found at $EXTENSION_DIR/manifest.json"
            exit 1
          fi

          # Show manifest for debugging
          echo "manifest.json contents:"
          cat "$EXTENSION_DIR/manifest.json"

          # Validate that required extension files exist
          for FILE in background.js content.js rules.json; do
            if [ ! -f "$EXTENSION_DIR/$FILE" ]; then
              echo "‚ö†Ô∏è Warning: Expected file $FILE not found in extension"
            fi
          done

          # Install Python dependencies for server.py
          if [ -f "$EXTENSION_DIR/requirements.txt" ]; then
            pip install -r "$EXTENSION_DIR/requirements.txt"
          else
            echo "‚ö†Ô∏è No requirements.txt found, skipping pip install"
          fi

          echo "‚úÖ BotXByte Extension setup complete"
          echo "  Extension path: $EXTENSION_DIR"
          echo "  manifest.json present: $(test -f $EXTENSION_DIR/manifest.json && echo yes || echo no)"
          echo "  server.py present: $(test -f $EXTENSION_DIR/server.py && echo yes || echo no)"

      - name: Start BotXByte Server
        if: steps.config.outputs.vnc_enabled == 'true'
        id: botxbyte_server
        run: |
          echo "Starting BotXByte server (server.py)..."

          EXTENSION_DIR="$HOME/real-botxbyte-extension"

          # Export environment variables for server.py
          export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"

          # Start server.py in background
          cd "$EXTENSION_DIR"
          nohup python3 server.py > /tmp/botxbyte-server.log 2>&1 &
          SERVER_PID=$!
          echo "server_pid=$SERVER_PID" >> $GITHUB_OUTPUT

          sleep 3

          if kill -0 $SERVER_PID 2>/dev/null; then
            echo "‚úÖ BotXByte server started (PID: $SERVER_PID)"
            echo "  WebSocket: ws://localhost:8765"
            echo "  HTTP API:  http://localhost:8766"
          else
            echo "‚ùå BotXByte server failed to start"
            cat /tmp/botxbyte-server.log
            exit 1
          fi

      - name: Launch Chrome with BotXByte Extension
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Launching Chrome with BotXByte extension on VNC desktop..."

          export DISPLAY=:1
          export NO_AT_BRIDGE=1
          export DBUS_SESSION_BUS_ADDRESS=/dev/null

          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          CHROME_PROFILE_DIR="$HOME/chrome-botxbyte-profile"

          # Clean any previous profile
          rm -rf "$CHROME_PROFILE_DIR"
          mkdir -p "$CHROME_PROFILE_DIR"

          # --- Verify extension directory ---
          if [ ! -f "$EXTENSION_DIR/manifest.json" ]; then
            echo "‚ùå Extension manifest.json not found"
            ls -laR "$EXTENSION_DIR/" 2>/dev/null || echo "Directory does not exist"
            exit 1
          fi

          # Remove stale _metadata if present
          rm -rf "$EXTENSION_DIR/_metadata" 2>/dev/null || true

          echo "Extension manifest:"
          python3 -c "import json; m=json.load(open('$EXTENSION_DIR/manifest.json')); print(f\"  Name: {m.get('name','?')}\"); print(f\"  Version: {m.get('version','?')}\"); print(f\"  Manifest V{m.get('manifest_version','?')}\")"

          echo "Extension files:"
          ls -1 "$EXTENSION_DIR/"

          # --- Chrome policy ---
          sudo mkdir -p /etc/opt/chrome/policies/managed
          echo '{
            "ExtensionSettings": {
              "*": {
                "installation_mode": "allowed"
              }
            },
            "DeveloperToolsAvailability": 1,
            "ExtensionDeveloperModeAllowed": true,
            "BlockExternalExtensions": false
          }' | sudo tee /etc/opt/chrome/policies/managed/allow_dev_extensions.json > /dev/null

          # ================================================================
          # PHASE 1: Initialize Chrome profile (headless, no extension)
          # This creates the profile with proper Secure Preferences HMACs
          # ================================================================
          echo "Phase 1: Initializing Chrome profile..."
          touch "$CHROME_PROFILE_DIR/First Run"

          google-chrome \
            --headless=new \
            --no-first-run \
            --no-sandbox \
            --disable-gpu \
            --disable-dev-shm-usage \
            --user-data-dir="$CHROME_PROFILE_DIR" \
            --dump-dom "about:blank" > /dev/null 2>&1 || true

          sleep 3

          # Kill headless Chrome
          pkill -f "google-chrome" 2>/dev/null || true
          sleep 2

          echo "  Profile created. Files:"
          ls -la "$CHROME_PROFILE_DIR/Default/" 2>/dev/null | head -10

          # ================================================================
          # PHASE 2: Enable developer mode in the initialized profile
          # Delete Secure Preferences so Chrome re-hashes from Preferences
          # ================================================================
          echo "Phase 2: Enabling developer mode in profile..."

          python3 << 'PYEOF'
          import json, os, sys

          profile_dir = os.path.expanduser("~/chrome-botxbyte-profile/Default")
          prefs_file = os.path.join(profile_dir, "Preferences")
          secure_prefs_file = os.path.join(profile_dir, "Secure Preferences")

          # Read and modify Preferences
          if os.path.exists(prefs_file):
              with open(prefs_file) as f:
                  prefs = json.load(f)
          else:
              prefs = {}

          # Enable developer mode
          prefs.setdefault("extensions", {}).setdefault("ui", {})["developer_mode"] = True

          # Set clean exit to avoid recovery prompts
          prefs.setdefault("profile", {})["exited_cleanly"] = True
          prefs.setdefault("profile", {})["exit_type"] = "Normal"

          with open(prefs_file, "w") as f:
              json.dump(prefs, f, indent=2)
          print("  Preferences updated: developer_mode=true")

          # Delete Secure Preferences to force Chrome to re-compute HMACs
          # from the current Preferences values (including our developer_mode=true)
          if os.path.exists(secure_prefs_file):
              os.remove(secure_prefs_file)
              print("  Secure Preferences deleted (Chrome will re-hash)")
          else:
              print("  No Secure Preferences found")

          # Also check for Local State
          local_state = os.path.expanduser("~/chrome-botxbyte-profile/Local State")
          if os.path.exists(local_state):
              with open(local_state) as f:
                  state = json.load(f)
              # Clear any protection MACs in Local State
              if "protection" in state:
                  del state["protection"]
                  with open(local_state, "w") as f:
                      json.dump(state, f, indent=2)
                  print("  Local State protection MACs cleared")

          print("  Developer mode configuration complete")
          PYEOF

          # ================================================================
          # PHASE 3: Launch Chrome with extension
          # ================================================================
          echo "Phase 3: Launching Chrome with extension..."
          echo "  Extension dir: $EXTENSION_DIR"
          echo "  Profile dir: $CHROME_PROFILE_DIR"

          google-chrome \
            --no-first-run \
            --no-default-browser-check \
            --disable-gpu \
            --no-sandbox \
            --disable-dev-shm-usage \
            --enable-extensions \
            --load-extension="$EXTENSION_DIR" \
            --user-data-dir="$CHROME_PROFILE_DIR" \
            --remote-debugging-port=9222 \
            --new-window \
            "chrome://extensions" \
            2>/tmp/chrome-stderr.log &

          CHROME_PID=$!
          echo "Chrome PID: $CHROME_PID"

          # Wait for Chrome to fully initialize
          sleep 12

          if ! pgrep -f "google-chrome" > /dev/null; then
            echo "‚ùå Chrome failed to launch"
            tail -30 /tmp/chrome-stderr.log 2>/dev/null || true
            exit 1
          fi

          echo "‚úÖ Chrome process is running"

          # ================================================================
          # PHASE 4: Verify extension via Chrome DevTools Protocol
          # ================================================================
          echo "Phase 4: Verifying extension via CDP..."

          python3 << 'PYEOF'
          import urllib.request, json, time

          def cdp_request(url):
              try:
                  req = urllib.request.Request(url)
                  with urllib.request.urlopen(req, timeout=5) as resp:
                      return json.loads(resp.read())
              except Exception as e:
                  return None

          # Check open tabs/targets
          targets = cdp_request("http://localhost:9222/json/list")
          if targets:
              print(f"  Chrome targets: {len(targets)}")
              for t in targets:
                  ttype = t.get("type", "?")
                  url = t.get("url", "?")
                  title = t.get("title", "?")
                  print(f"    [{ttype}] {title} - {url}")

                  # Service worker = extension background script is running
                  if ttype == "service_worker":
                      print(f"  ‚úÖ Extension service worker is RUNNING: {url}")

              # Check for extension targets (background pages, service workers)
              ext_targets = [t for t in targets if "extension" in t.get("url", "").lower() or t.get("type") == "service_worker"]
              if ext_targets:
                  print(f"  ‚úÖ Found {len(ext_targets)} extension target(s) - extension is ACTIVE")
              else:
                  print("  ‚ö†Ô∏è No extension targets found - extension may not be active")
                  print("  Checking chrome://extensions page for details...")
          else:
              print("  ‚ö†Ô∏è Could not connect to Chrome DevTools Protocol")

          # Also check version info
          version = cdp_request("http://localhost:9222/json/version")
          if version:
              print(f"  Chrome: {version.get('Browser', '?')}")
          PYEOF

          # Check if server.py is still running
          if pgrep -f "server.py" > /dev/null; then
            echo "‚úÖ BotXByte server is running"
          else
            echo "‚ö†Ô∏è BotXByte server is NOT running"
            cat /tmp/botxbyte-server.log 2>/dev/null || true
          fi

          echo "‚úÖ Chrome launch complete"
          echo "  Profile dir: $CHROME_PROFILE_DIR"
          echo "  Extension should auto-connect to ws://localhost:8765"

      - name: Install cloudflared
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Installing cloudflared..."
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          cloudflared --version

      - name: Create Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        id: tunnel
        run: |
          echo "Creating Cloudflare Tunnel..."

          RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel" \
            --request POST \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data '{
              "name": "github-vnc-'$(date +%s)'",
              "config_src": "cloudflare"
            }')

          # Check if tunnel creation was successful
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false')
          if [ "$SUCCESS" != "true" ]; then
            echo "‚ùå Failed to create tunnel"
            echo "$RESPONSE" | jq '.'
            exit 1
          fi

          TUNNEL_ID=$(echo "$RESPONSE" | jq -r '.result.id')
          TUNNEL_TOKEN=$(echo "$RESPONSE" | jq -r '.result.token')

          if [ -z "$TUNNEL_ID" ] || [ "$TUNNEL_ID" = "null" ]; then
            echo "‚ùå Failed to extract tunnel ID"
            exit 1
          fi

          echo "tunnel_id=$TUNNEL_ID" >> $GITHUB_OUTPUT
          echo "tunnel_token=$TUNNEL_TOKEN" >> $GITHUB_OUTPUT
          echo "‚úÖ Tunnel created: $TUNNEL_ID"

      - name: Configure Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Configuring tunnel for noVNC..."

          RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel/${{ steps.tunnel.outputs.tunnel_id }}/configurations" \
            --request PUT \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data "{
              \"config\": {
                \"ingress\": [
                  {
                    \"hostname\": \"${{ steps.config.outputs.hostname }}\",
                    \"path\": \"/vnc/*\",
                    \"service\": \"http://localhost:${NOVNC_PORT}\",
                    \"originRequest\": {}
                  },
                  {
                    \"hostname\": \"${{ steps.config.outputs.hostname }}\",
                    \"path\": \"/browser-agent-management-service/*\",
                    \"service\": \"http://localhost:8801\",
                    \"originRequest\": {}
                  },
                  {
                    \"hostname\": \"${{ steps.config.outputs.hostname }}\",
                    \"service\": \"http://localhost:${NOVNC_PORT}\",
                    \"originRequest\": {}
                  },
                  {
                    \"service\": \"http_status:404\"
                  }
                ]
              }
            }")

          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" != "true" ]; then
            echo "‚ùå Failed to configure tunnel"
            echo "$RESPONSE" | jq '.'
            exit 1
          fi

          echo "‚úÖ Tunnel configured"

      - name: Create DNS Record
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Creating DNS record..."

          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          echo "Hostname: $FULL_HOSTNAME"
          echo "Tunnel ID: ${{ steps.tunnel.outputs.tunnel_id }}"
          echo "Target: ${{ steps.tunnel.outputs.tunnel_id }}.cfargotunnel.com"

          # Check for existing DNS record
          EXISTING_RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records?name=${FULL_HOSTNAME}" \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}")

          echo "Existing DNS check response:"
          echo "$EXISTING_RESPONSE" | jq '.'

          EXISTING=$(echo "$EXISTING_RESPONSE" | jq -r '.result[0].id // empty')

          if [ -n "$EXISTING" ]; then
            echo "‚ö†Ô∏è DNS record already exists (ID: $EXISTING), deleting..."
            DELETE_RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
              "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records/${EXISTING}" \
              --request DELETE \
              --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}")
            echo "Delete response:"
            echo "$DELETE_RESPONSE" | jq '.'
            sleep 2
          fi

          # Create new DNS record
          echo "Creating new DNS record..."
          RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records" \
            --request POST \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data "{
              \"type\": \"CNAME\",
              \"proxied\": true,
              \"name\": \"${FULL_HOSTNAME}\",
              \"content\": \"${{ steps.tunnel.outputs.tunnel_id }}.cfargotunnel.com\"
            }")

          echo "Create DNS response:"
          echo "$RESPONSE" | jq '.'

          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" != "true" ]; then
            echo "‚ùå Failed to create DNS record"
            echo "Error details:"
            echo "$RESPONSE" | jq '.errors'
            exit 1
          fi

          DNS_RECORD_ID=$(echo "$RESPONSE" | jq -r '.result.id')
          echo "‚úÖ DNS record created successfully (ID: $DNS_RECORD_ID)"

      - name: Start Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Starting Cloudflare Tunnel..."
          cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
          sleep 10

          if ! pgrep -x "cloudflared" > /dev/null; then
            echo "‚ùå Cloudflare tunnel failed to start"
            cat /tmp/tunnel.log
            exit 1
          fi

          echo "‚úÖ Cloudflare Tunnel started"

      - name: Display VNC Connection Info
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë          üéâ UBUNTU DESKTOP VNC IS NOW RUNNING! üéâ            ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "üåê Access URL: https://${{ steps.config.outputs.hostname }}/vnc.html"
          echo "üîë Password: (configured)"
          echo ""
          echo "üîå BotXByte Extension: Loaded in Chrome (auto-connected to server.py)"
          echo "   WebSocket: ws://localhost:8765"
          echo "   HTTP API:  http://localhost:8766"
          echo ""

      - name: Run Moti on Desktop
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export DISPLAY=:1
          export NO_AT_BRIDGE=1
          export SESSION_MANAGER=""
          export DBUS_SESSION_BUS_ADDRESS=/dev/null
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ffmpeg libavcodec-dev libavformat-dev libavdevice-dev libavutil-dev libavfilter-dev libswscale-dev libswresample-dev pkg-config


          # Run Moti in a visible terminal on the desktop
          xfce4-terminal --maximize --title="Moti Process" \
            --command="bash -c 'export MOTI_JOB_CONFIG=\$(echo \"${{ inputs.base64_config }}\" | base64 -d) && pip install av --upgrade && pip install moti && moti; echo \"Moti completed. Press Enter to close...\"; read'" 2>/dev/null &

          sleep 5

          # Verify terminal launched
          if pgrep -f "xfce4-terminal" > /dev/null; then
            echo "‚úÖ Moti started in desktop terminal"
          else
            echo "‚ö†Ô∏è Terminal may not have started, but continuing..."
          fi

      - name: Run Moti in Normal Terminal
        if: steps.config.outputs.vnc_enabled == 'false'
        timeout-minutes: 30
        run: |
          echo "Running Moti in normal terminal (no VNC)..."

          # Decode and export config
          export MOTI_JOB_CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)

          pip install moti
          moti
          echo "‚úÖ Moti completed"

      - name: Keep VNC Session Alive
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          export DBUS_SESSION_BUS_ADDRESS=/dev/null

          echo "Keeping VNC session alive..."

          # Monitor for 30 mins (1800 seconds)
          END_TIME=$((SECONDS + 1800))

          while [ $SECONDS -lt $END_TIME ]; do
            REMAINING=$((END_TIME - SECONDS))
            HOURS=$((REMAINING / 3600))
            MINUTES=$(((REMAINING % 3600) / 60))

            if [ "${{ steps.config.outputs.cloudflare_enabled }}" = "true" ]; then
              echo "‚è±Ô∏è Remaining: ${HOURS}h ${MINUTES}m | Access: https://${{ steps.config.outputs.hostname }}/vnc.html"
            else
              echo "‚è±Ô∏è Remaining: ${HOURS}h ${MINUTES}m | VNC running locally"
            fi

            # Check and restart VNC if needed
            if ! pgrep -f "Xvnc.*:1" > /dev/null; then
              echo "‚ùå VNC stopped! Restarting..."
              vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT
              sleep 3
              if ! pgrep -f "Xvnc.*:1" > /dev/null; then
                echo "‚ùå Failed to restart VNC! Exiting..."
                exit 1
              fi
              echo "‚úÖ VNC restarted successfully"
            fi

            # Check and restart tunnel if Cloudflare is enabled
            if [ "${{ steps.config.outputs.cloudflare_enabled }}" = "true" ]; then
              if ! pgrep -x "cloudflared" > /dev/null; then
                echo "‚ùå Tunnel stopped! Restarting..."
                cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
                sleep 5
                if ! pgrep -x "cloudflared" > /dev/null; then
                  echo "‚ùå Failed to restart tunnel! Exiting..."
                  cat /tmp/tunnel.log
                  exit 1
                fi
                echo "‚úÖ Tunnel restarted successfully"
              fi
            fi

            # Check and restart BotXByte server if needed
            if ! kill -0 ${{ steps.botxbyte_server.outputs.server_pid }} 2>/dev/null; then
              echo "‚ùå BotXByte server stopped! Restarting..."
              EXTENSION_DIR="$HOME/real-botxbyte-extension"
              cd "$EXTENSION_DIR"
              export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
              nohup python3 server.py > /tmp/botxbyte-server.log 2>&1 &
              sleep 3
              if pgrep -f "server.py" > /dev/null; then
                echo "‚úÖ BotXByte server restarted"
              else
                echo "‚ö†Ô∏è BotXByte server failed to restart"
                cat /tmp/botxbyte-server.log
              fi
            fi

            # Check and restart Chrome if needed
            if ! pgrep -f "google-chrome" > /dev/null; then
              echo "‚ùå Chrome stopped! Restarting..."
              export DISPLAY=:1
              export NO_AT_BRIDGE=1
              export DBUS_SESSION_BUS_ADDRESS=/dev/null
              EXTENSION_DIR="$HOME/real-botxbyte-extension"
              CHROME_PROFILE_DIR="$HOME/chrome-botxbyte-profile"
              google-chrome \
                --no-first-run \
                --no-default-browser-check \
                --disable-gpu \
                --no-sandbox \
                --disable-dev-shm-usage \
                --enable-extensions \
                --load-extension="$EXTENSION_DIR" \
                --user-data-dir="$CHROME_PROFILE_DIR" \
                --remote-debugging-port=9222 \
                --new-window \
                "chrome://extensions" \
                2>/tmp/chrome-stderr.log &
              sleep 5
              if pgrep -f "google-chrome" > /dev/null; then
                echo "‚úÖ Chrome restarted with BotXByte extension"
              else
                echo "‚ö†Ô∏è Chrome failed to restart"
              fi
            fi

            sleep 30
          done

          echo "‚úÖ Session time expired"

      - name: Cleanup Webshare IP Authorization
        if: always() && steps.config.outputs.webshare_enabled == 'true'
        run: |
          echo "Deregistering IP from Webshare..."

          if [ -n "${{ steps.webshare.outputs.webshare_auth_id }}" ] && [ "${{ steps.webshare.outputs.webshare_auth_id }}" != "null" ]; then
            DELETE_RESPONSE=$(curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/${{ steps.webshare.outputs.webshare_auth_id }}/" \
              -X DELETE \
              -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}")

            # Check if deletion was successful (empty response or 204 status)
            if [ -z "$DELETE_RESPONSE" ] || [ "$DELETE_RESPONSE" = "{}" ]; then
              echo "‚úÖ IP authorization removed from Webshare"
            else
              echo "‚ö†Ô∏è Failed to remove IP authorization"
              echo "$DELETE_RESPONSE"
            fi
          else
            echo "‚ö†Ô∏è No Webshare authorization ID found to delete"
          fi

          echo "‚úÖ Webshare cleanup complete"

      - name: Cleanup BotXByte Server
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          echo "Cleaning up BotXByte server and Chrome..."

          # Kill Chrome
          pkill -f "google-chrome" || true

          # Kill server.py
          pkill -f "server.py" || true

          sleep 2
          echo "‚úÖ BotXByte cleanup complete"

      - name: Cleanup Cloudflare Tunnel and DNS
        if: always() && steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo "Cleaning up Cloudflare tunnel and DNS record..."

          # Stop cloudflared process
          pkill -x cloudflared || true
          sleep 2

          # Delete tunnel info from AI Management Service
          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          if [ -n "$FULL_HOSTNAME" ] && [ "$FULL_HOSTNAME" != "null" ]; then
            echo "Deleting tunnel info from AI Management Service..."

            USER_ID="${{ steps.config.outputs.user_id }}"
            WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
            BROWSER_PROFILE_ID="${{ steps.config.outputs.browser_profile_id }}"

            # Build URL with parameters
            DELETE_URL="http://129.212.196.173/ai-management-service/api/v1/cloudflare-tunnel-info/delete/?tunnel_url=https://${FULL_HOSTNAME}"

            # Add browser_profile_id if it exists
            if [ -n "$BROWSER_PROFILE_ID" ] && [ "$BROWSER_PROFILE_ID" != "null" ]; then
              DELETE_URL="${DELETE_URL}&browser_profile_id=${BROWSER_PROFILE_ID}"
            fi

            DELETE_TUNNEL_INFO=$(curl -s "$DELETE_URL" \
              -X DELETE \
              -H "user-id: ${USER_ID}" \
              -H "workspace-id: ${WORKSPACE_ID}")

            echo "Tunnel info deletion response:"
            echo "$DELETE_TUNNEL_INFO"
          fi

          # Delete DNS record
          if [ -n "$FULL_HOSTNAME" ] && [ "$FULL_HOSTNAME" != "null" ]; then
            echo "Deleting DNS record for ${FULL_HOSTNAME}..."
            EXISTING_DNS=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
              "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records?name=${FULL_HOSTNAME}" \
              --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" | jq -r '.result[0].id // empty')

            if [ -n "$EXISTING_DNS" ]; then
              DELETE_RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
                "https://api.cloudflare.com/client/v4/zones/${{ steps.config.outputs.cloudflare_zone_id }}/dns_records/${EXISTING_DNS}" \
                --request DELETE \
                --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}")

              DELETE_SUCCESS=$(echo "$DELETE_RESPONSE" | jq -r '.success // false')
              if [ "$DELETE_SUCCESS" = "true" ]; then
                echo "‚úÖ DNS record deleted successfully"
              else
                echo "‚ö†Ô∏è Failed to delete DNS record"
                echo "$DELETE_RESPONSE" | jq '.'
              fi
            else
              echo "‚ö†Ô∏è DNS record not found"
            fi
          fi

          # Delete Cloudflare tunnel
          if [ -n "${{ steps.tunnel.outputs.tunnel_id }}" ] && [ "${{ steps.tunnel.outputs.tunnel_id }}" != "null" ]; then
            echo "Deleting Cloudflare tunnel ${{ steps.tunnel.outputs.tunnel_id }}..."
            TUNNEL_DELETE_RESPONSE=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
              "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel/${{ steps.tunnel.outputs.tunnel_id }}" \
              --request DELETE \
              --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}")

            TUNNEL_DELETE_SUCCESS=$(echo "$TUNNEL_DELETE_RESPONSE" | jq -r '.success // false')
            if [ "$TUNNEL_DELETE_SUCCESS" = "true" ]; then
              echo "‚úÖ Cloudflare tunnel deleted successfully"
            else
              echo "‚ö†Ô∏è Failed to delete Cloudflare tunnel"
              echo "$TUNNEL_DELETE_RESPONSE" | jq '.'
            fi
          else
            echo "‚ö†Ô∏è Tunnel ID not found"
          fi

          echo "‚úÖ Cloudflare cleanup complete"

      - name: Cleanup VNC
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          echo "Cleaning up VNC server..."

          vncserver -kill :1 || true

          echo "‚úÖ VNC cleanup complete"
