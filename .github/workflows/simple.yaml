name: VNC Data Static Timeout
on:
  workflow_dispatch:
    inputs:
      base64_config:
        description: 'Base64 encoded JSON configuration'
        required: true
        type: string

env:
  DISPLAY: :1
  VNC_PORT: 5901
  NOVNC_PORT: 6080

jobs:
  process:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Fetch and Parse Config
        id: config
        run: |
          CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)

          VNC_ENABLED=$(echo "$CONFIG" | jq -r '.vnc_enabled // "false"')
          CLOUDFLARE_ENABLED=$(echo "$CONFIG" | jq -r '.cloudflare_enabled // "false"')
          WEBSHARE_ENABLED=$(echo "$CONFIG" | jq -r '.webshare_enabled // "false"')
          echo "vnc_enabled=$VNC_ENABLED" >> $GITHUB_OUTPUT
          echo "cloudflare_enabled=$CLOUDFLARE_ENABLED" >> $GITHUB_OUTPUT
          echo "webshare_enabled=$WEBSHARE_ENABLED" >> $GITHUB_OUTPUT

          USER_ID=$(echo "$CONFIG" | jq -r '.user_id // "69c3090b-464d-4de3-9358-ceca1c9e2aa8"')
          WORKSPACE_ID=$(echo "$CONFIG" | jq -r '.workspace_id // "ceae1caa-1538-4859-8e1a-24a8b4904d5f"')
          echo "user_id=$USER_ID" >> $GITHUB_OUTPUT
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT

          if [ "$VNC_ENABLED" = "true" ]; then
            echo "vnc_password=$(echo "$CONFIG" | jq -r '.vnc_password // ""')" >> $GITHUB_OUTPUT
          fi

          if [ "$CLOUDFLARE_ENABLED" = "true" ]; then
            echo "cloudflare_api_token=$(echo "$CONFIG" | jq -r '.cloudflare_api_token // ""')" >> $GITHUB_OUTPUT
            echo "cloudflare_account_id=$(echo "$CONFIG" | jq -r '.cloudflare_account_id // ""')" >> $GITHUB_OUTPUT
            echo "cloudflare_zone_id=$(echo "$CONFIG" | jq -r '.cloudflare_zone_id // ""')" >> $GITHUB_OUTPUT
            echo "hostname=$(echo "$CONFIG" | jq -r '.hostname // ""')" >> $GITHUB_OUTPUT
            echo "browser_profile_id=$(echo "$CONFIG" | jq -r '.browser_profile_id // ""')" >> $GITHUB_OUTPUT
          fi

          if [ "$WEBSHARE_ENABLED" = "true" ]; then
            echo "webshare_api_token=$(echo "$CONFIG" | jq -r '.webshare_api_token // ""')" >> $GITHUB_OUTPUT
          fi

          echo "‚úÖ Config: VNC=$VNC_ENABLED | Cloudflare=$CLOUDFLARE_ENABLED | Webshare=$WEBSHARE_ENABLED"

      - name: Register IP with Webshare
        if: steps.config.outputs.webshare_enabled == 'true'
        id: webshare
        run: |
          PUBLIC_IP=$(curl -s 'https://api.ipify.org?format=json' | jq -r '.ip')
          RESPONSE=$(curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/" \
            -X POST -d "{\"ip_address\": \"$PUBLIC_IP\"}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}")
          AUTH_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
          [ -n "$AUTH_ID" ] \
            && echo "webshare_auth_id=$AUTH_ID" >> $GITHUB_OUTPUT \
            && echo "‚úÖ Webshare IP registered (Auth ID: $AUTH_ID)" \
            || echo "‚ö†Ô∏è Webshare registration failed"

      - name: Install Desktop Environment
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            xfce4 xfce4-goodies xfce4-terminal firefox \
            dbus-x11 dbus-user-session \
            x11-utils x11-apps x11-common x11-session-utils x11-xserver-utils \
            xfonts-base xfonts-100dpi xfonts-75dpi xfonts-cyrillic \
            xubuntu-icon-theme xubuntu-wallpapers gnome-icon-theme

      - name: Install Google Chrome
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
          sudo dpkg -i google-chrome-stable_current_amd64.deb || sudo apt-get install -f -y
          rm google-chrome-stable_current_amd64.deb
          google-chrome --version

      - name: Install TurboVNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          wget -q https://phoenixnap.dl.sourceforge.net/project/turbovnc/2.2.5/turbovnc_2.2.5_amd64.deb
          sudo dpkg -i turbovnc_2.2.5_amd64.deb
          rm turbovnc_2.2.5_amd64.deb

      - name: Install noVNC
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          cd ~
          git clone https://github.com/novnc/noVNC.git
          cd noVNC && git clone https://github.com/novnc/websockify.git

      - name: Configure and Start VNC Server
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          mkdir -p ~/.vnc
          echo "${{ steps.config.outputs.vnc_password }}" | vncpasswd -f > ~/.vnc/passwd
          chmod 600 ~/.vnc/passwd
          cat > ~/.vnc/xstartup.turbovnc << 'EOF'
          #!/bin/bash
          export NO_AT_BRIDGE=1
          export SESSION_MANAGER=""
          dbus-launch /usr/bin/startxfce4 &
          EOF
          chmod +x ~/.vnc/xstartup.turbovnc
          vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT 2>&1 | tee /tmp/vnc-start.log
          sleep 8
          pgrep -f "Xvnc.*:1" > /dev/null && echo "‚úÖ VNC started" || { cat /tmp/vnc-start.log; exit 1; }

      - name: Install Python dependencies
        if: steps.config.outputs.vnc_enabled == 'true'
        run: pip install numpy websocket-client

      - name: Start noVNC
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          cd ~/noVNC
          [ ! -f ./utils/websockify/run ] && cd utils && git clone https://github.com/novnc/websockify.git && cd ..
          ./utils/novnc_proxy --vnc localhost:$VNC_PORT --listen $NOVNC_PORT &
          sleep 5
          ss -tuln | grep -q ":$NOVNC_PORT " && echo "‚úÖ noVNC started" || echo "‚ö†Ô∏è noVNC may still be binding..."

      - name: Download and Setup BotXByte Extension
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          EXTENSION_DIR="$HOME/real-botxbyte-extension"

          wget -q -O /tmp/real-botxbyte-extension.zip \
            "https://github.com/user-attachments/files/25434674/real-botxbyte-extension.zip"

          TEMP_EXTRACT="/tmp/extension-extract"
          rm -rf "$TEMP_EXTRACT" && mkdir -p "$TEMP_EXTRACT"
          unzip -o /tmp/real-botxbyte-extension.zip -d "$TEMP_EXTRACT"
          rm /tmp/real-botxbyte-extension.zip

          MANIFEST_PATH=$(find "$TEMP_EXTRACT" -name "manifest.json" -type f | head -1)
          [ -z "$MANIFEST_PATH" ] && echo "‚ùå manifest.json not found" && exit 1

          rm -rf "$EXTENSION_DIR"
          mv "$(dirname "$MANIFEST_PATH")" "$EXTENSION_DIR"
          rm -rf "$TEMP_EXTRACT"

          # Remove files Chrome rejects
          rm -rf "$EXTENSION_DIR/_metadata" "$EXTENSION_DIR/.git"
          rm -f "$EXTENSION_DIR/.gitignore" "$EXTENSION_DIR/.env.dev" \
                "$EXTENSION_DIR/README.md" "$EXTENSION_DIR/llm.txt"

          echo "=== manifest.json ==="
          cat "$EXTENSION_DIR/manifest.json"
          echo ""
          echo "=== Extension files ==="
          find "$EXTENSION_DIR" -type f | sort

          [ -f "$EXTENSION_DIR/requirements.txt" ] && pip install -r "$EXTENSION_DIR/requirements.txt" || true
          echo "‚úÖ Extension ready: $EXTENSION_DIR"

      - name: Start BotXByte Server
        if: steps.config.outputs.vnc_enabled == 'true'
        id: botxbyte_server
        run: |
          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
          cd "$EXTENSION_DIR"
          nohup python3 server.py > /tmp/botxbyte-server.log 2>&1 &
          SERVER_PID=$!
          echo "server_pid=$SERVER_PID" >> $GITHUB_OUTPUT
          sleep 3
          kill -0 $SERVER_PID 2>/dev/null \
            && echo "‚úÖ BotXByte server started (PID: $SERVER_PID)" \
            || { echo "‚ùå Server failed"; cat /tmp/botxbyte-server.log; exit 1; }

      - name: Launch Chrome and Load Extension via Developer Mode
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export DISPLAY=:1
          export NO_AT_BRIDGE=1
          export DBUS_SESSION_BUS_ADDRESS=/dev/null

          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          CHROME_PROFILE_DIR="$HOME/chrome-botxbyte-profile"

          rm -rf "$CHROME_PROFILE_DIR"
          mkdir -p "$CHROME_PROFILE_DIR/Default"

          # Allow unpacked extensions via policy
          sudo mkdir -p /etc/opt/chrome/policies/managed
          cat << 'POLICY' | sudo tee /etc/opt/chrome/policies/managed/policy.json > /dev/null
          {
            "ExtensionSettings": {
              "*": { "installation_mode": "allowed" }
            },
            "DeveloperToolsAvailability": 1,
            "ExtensionDeveloperModeAllowed": true,
            "BlockExternalExtensions": false
          }
          POLICY

          touch "$CHROME_PROFILE_DIR/First Run"

          # -------------------------------------------------------
          # STEP 1: Launch Chrome WITHOUT any extension
          # Open chrome://extensions so the UI is ready
          # -------------------------------------------------------
          echo "Step 1: Launching Chrome (no extension yet)..."
          google-chrome \
            --no-first-run \
            --no-default-browser-check \
            --disable-gpu \
            --no-sandbox \
            --disable-dev-shm-usage \
            --enable-extensions \
            --user-data-dir="$CHROME_PROFILE_DIR" \
            --remote-debugging-port=9222 \
            --remote-allow-origins='*' \
            --new-window \
            "chrome://extensions" \
            2>/tmp/chrome-stderr.log &

          CHROME_PID=$!
          echo "  Chrome PID: $CHROME_PID"
          sleep 12

          if ! pgrep -f "google-chrome" > /dev/null; then
            echo "‚ùå Chrome failed to launch"
            cat /tmp/chrome-stderr.log
            exit 1
          fi
          echo "  ‚úÖ Chrome running"

          # -------------------------------------------------------
          # STEP 2 + 3: Via CDP ‚Äî
          #   2. Enable developer mode (toggle in chrome://extensions UI)
          #   3. Load the extension using Chrome's loadUnpacked API
          #      (this is the EXACT same thing as clicking Load Unpacked)
          # -------------------------------------------------------
          python3 << PYEOF
          import websocket, json, time, urllib.request, sys, os

          EXTENSION_DIR = os.path.expanduser("~/real-botxbyte-extension")

          def cdp_http(path):
              try:
                  resp = urllib.request.urlopen(f"http://localhost:9222{path}", timeout=10)
                  return json.loads(resp.read())
              except Exception as e:
                  print(f"  CDP HTTP error: {e}")
                  return None

          def cdp_send(ws, method, params=None, msg_id=1):
              msg = {"id": msg_id, "method": method}
              if params:
                  msg["params"] = params
              ws.send(json.dumps(msg))
              for _ in range(300):
                  try:
                      resp = json.loads(ws.recv())
                      if resp.get("id") == msg_id:
                          return resp
                  except:
                      break
              return {}

          # Find chrome://extensions tab
          print("Finding chrome://extensions tab...")
          ext_tab = None
          for attempt in range(10):
              targets = cdp_http("/json/list") or []
              ext_tab = next((t for t in targets if "chrome://extensions" in t.get("url","")), None)
              if ext_tab:
                  break
              time.sleep(2)
              print(f"  Waiting for extensions tab... attempt {attempt+1}/10")

          if not ext_tab:
              print("‚ùå chrome://extensions tab not found")
              sys.exit(1)

          ws_url = ext_tab.get("webSocketDebuggerUrl")
          if not ws_url:
              print("‚ùå No WebSocket URL for extensions tab")
              sys.exit(1)

          print(f"  Connected to: {ext_tab.get('url')}")
          ws = websocket.create_connection(ws_url, timeout=20)
          time.sleep(3)

          # ---- STEP 2: Enable Developer Mode ----
          print("\nStep 2: Enabling developer mode...")
          toggle_result = cdp_send(ws, "Runtime.evaluate", {
              "expression": """
              (async () => {
                  for (let i = 0; i < 30; i++) {
                      const mgr = document.querySelector('extensions-manager');
                      if (mgr && mgr.shadowRoot) {
                          const toolbar = mgr.shadowRoot.querySelector('extensions-toolbar');
                          if (toolbar && toolbar.shadowRoot) {
                              const toggle = toolbar.shadowRoot.querySelector('#devMode');
                              if (toggle) {
                                  if (!toggle.checked) {
                                      toggle.click();
                                      await new Promise(r => setTimeout(r, 1500));
                                  }
                                  return toggle.checked ? 'ON' : 'OFF';
                              }
                          }
                      }
                      await new Promise(r => setTimeout(r, 500));
                  }
                  return 'TIMEOUT';
              })()
              """,
              "awaitPromise": True
          }, msg_id=1)

          dev_mode = toggle_result.get("result",{}).get("result",{}).get("value","?")
          print(f"  Developer mode: {dev_mode}")

          if dev_mode not in ("ON", "ALREADY_ON"):
              print(f"  ‚ö†Ô∏è  Could not confirm developer mode ON (got: {dev_mode})")
              # Continue anyway ‚Äî policy may have already set it

          time.sleep(2)

          # ---- STEP 3: Load Extension using Chrome's internal API ----
          # chrome.developerPrivate.loadUnpacked is the EXACT API the
          # "Load unpacked" button calls. We call it directly via CDP.
          # This is 100% equivalent to manually clicking Load Unpacked.
          print(f"\nStep 3: Loading extension from: {EXTENSION_DIR}")

          load_result = cdp_send(ws, "Runtime.evaluate", {
              "expression": f"""
              (async () => {{
                  return await new Promise((resolve) => {{
                      chrome.developerPrivate.loadUnpacked(
                          {{ location: {json.dumps(EXTENSION_DIR)} }},
                          (extensionInfo) => {{
                              if (chrome.runtime.lastError) {{
                                  resolve('ERROR: ' + chrome.runtime.lastError.message);
                              }} else {{
                                  resolve('OK:' + (extensionInfo ? extensionInfo.id : 'unknown'));
                              }}
                          }}
                      );
                  }});
              }})()
              """,
              "awaitPromise": True
          }, msg_id=2)

          load_val = load_result.get("result",{}).get("result",{}).get("value","")
          print(f"  loadUnpacked result: {load_val}")

          if load_val.startswith("ERROR:"):
              print(f"  ‚ùå Failed to load extension: {load_val}")
              # Try alternative approach: loadUnpacked with just path string
              print("  Trying alternative loadUnpacked call...")
              load_result2 = cdp_send(ws, "Runtime.evaluate", {
                  "expression": f"""
                  (async () => {{
                      return await new Promise((resolve) => {{
                          chrome.developerPrivate.loadUnpacked(
                              {json.dumps(EXTENSION_DIR)},
                              (info) => {{
                                  if (chrome.runtime.lastError) {{
                                      resolve('ERROR: ' + chrome.runtime.lastError.message);
                                  }} else {{
                                      resolve('OK:' + (info ? info.id : 'no-id'));
                                  }}
                              }}
                          );
                      }});
                  }})()
                  """,
                  "awaitPromise": True
              }, msg_id=3)
              load_val2 = load_result2.get("result",{}).get("result",{}).get("value","")
              print(f"  Alternative result: {load_val2}")
              load_val = load_val2

          ws.close()
          time.sleep(5)

          # ---- Verify: check CDP targets for extension ----
          print("\nVerifying extension is loaded...")
          targets = cdp_http("/json/list") or []
          print("  All CDP targets:")
          for t in targets:
              print(f"    [{t.get('type','?')}] {t.get('url','?')[:100]}")

          ext_found = False
          for t in targets:
              url = t.get("url","")
              ttype = t.get("type","")
              if "nmmhkkegccagdldgiimedpiccmgmieda" in url:
                  continue
              if ttype in ("service_worker", "background_page") and url.startswith("chrome-extension://"):
                  ext_id = url.split("/")[2]
                  print(f"\n  ‚úÖ Extension loaded successfully!")
                  print(f"     Type : {ttype}")
                  print(f"     ID   : {ext_id}")
                  print(f"     URL  : {url}")
                  ext_found = True
                  break

          if not ext_found:
              print("\n  ‚ö†Ô∏è  Extension background not visible in CDP targets")
              print("  Checking chrome://extensions UI for errors...")
              # Check extensions page for error details
              new_targets = cdp_http("/json/list") or []
              ext_tab2 = next((t for t in new_targets if "chrome://extensions" in t.get("url","")), None)
              if ext_tab2 and ext_tab2.get("webSocketDebuggerUrl"):
                  ws2 = websocket.create_connection(ext_tab2["webSocketDebuggerUrl"], timeout=15)
                  time.sleep(2)
                  check = cdp_send(ws2, "Runtime.evaluate", {
                      "expression": """
                      (async () => {
                          for (let i = 0; i < 20; i++) {
                              const mgr = document.querySelector('extensions-manager');
                              if (mgr && mgr.shadowRoot) {
                                  const items = [...mgr.shadowRoot.querySelectorAll('extensions-item')];
                                  return JSON.stringify(items.map(item => ({
                                      name: item.shadowRoot?.querySelector('#name')?.textContent?.trim(),
                                      id: item.id,
                                      enabled: item.shadowRoot?.querySelector('cr-toggle')?.checked,
                                      errors: item.shadowRoot?.querySelector('.errors-button')?.textContent?.trim()
                                  })));
                              }
                              await new Promise(r => setTimeout(r, 500));
                          }
                          return '[]';
                      })()
                      """,
                      "awaitPromise": True
                  }, msg_id=4)
                  raw = check.get("result",{}).get("result",{}).get("value","[]")
                  try:
                      items = json.loads(raw)
                      if items:
                          for item in items:
                              print(f"    Extension: {item.get('name')} (ID: {item.get('id')})")
                              print(f"      Enabled: {item.get('enabled')}")
                              if item.get('errors'):
                                  print(f"      ‚ö†Ô∏è Errors: {item.get('errors')}")
                      else:
                          print("    No extensions found in UI")
                  except:
                      print(f"    Raw: {raw[:300]}")
                  ws2.close()

          version = cdp_http("/json/version") or {}
          print(f"\nChrome: {version.get('Browser','?')}")
          PYEOF

          echo ""
          echo "=== Final Status ==="
          pgrep -f "google-chrome" > /dev/null && echo "‚úÖ Chrome        : running" || echo "‚ùå Chrome        : NOT running"
          pgrep -f "server.py"     > /dev/null && echo "‚úÖ BotXByte srv  : running" || echo "‚ö†Ô∏è BotXByte srv  : NOT running"

      - name: Install cloudflared
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          cloudflared --version

      - name: Create Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        id: tunnel
        run: |
          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel" \
            --request POST \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data '{"name":"github-vnc-'"$(date +%s)"'","config_src":"cloudflare"}')
          [ "$(echo "$RESPONSE" | jq -r '.success')" != "true" ] && echo "$RESPONSE" | jq '.' && exit 1
          echo "tunnel_id=$(echo "$RESPONSE" | jq -r '.result.id')" >> $GITHUB_OUTPUT
          echo "tunnel_token=$(echo "$RESPONSE" | jq -r '.result.token')" >> $GITHUB_OUTPUT
          echo "‚úÖ Tunnel created"

      - name: Configure Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/accounts/${{ steps.config.outputs.cloudflare_account_id }}/cfd_tunnel/${{ steps.tunnel.outputs.tunnel_id }}/configurations" \
            --request PUT \
            --header "Authorization: Bearer ${{ steps.config.outputs.cloudflare_api_token }}" \
            --header "Content-Type: application/json" \
            --data "{\"config\":{\"ingress\":[
              {\"hostname\":\"${{ steps.config.outputs.hostname }}\",\"path\":\"/vnc/*\",\"service\":\"http://localhost:${NOVNC_PORT}\",\"originRequest\":{}},
              {\"hostname\":\"${{ steps.config.outputs.hostname }}\",\"path\":\"/browser-agent-management-service/*\",\"service\":\"http://localhost:8801\",\"originRequest\":{}},
              {\"hostname\":\"${{ steps.config.outputs.hostname }}\",\"service\":\"http://localhost:${NOVNC_PORT}\",\"originRequest\":{}},
              {\"service\":\"http_status:404\"}
            ]}}")
          [ "$(echo "$RESPONSE" | jq -r '.success')" = "true" ] && echo "‚úÖ Tunnel configured" || { echo "$RESPONSE" | jq '.'; exit 1; }

      - name: Create DNS Record
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          ZONE="${{ steps.config.outputs.cloudflare_zone_id }}"
          TOKEN="${{ steps.config.outputs.cloudflare_api_token }}"

          EXISTING=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records?name=${FULL_HOSTNAME}" \
            --header "Authorization: Bearer ${TOKEN}" | jq -r '.result[0].id // empty')
          [ -n "$EXISTING" ] && curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records/${EXISTING}" \
            --request DELETE --header "Authorization: Bearer ${TOKEN}" > /dev/null && sleep 2

          RESPONSE=$(curl -s -A "Mozilla/5.0" \
            "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records" \
            --request POST \
            --header "Authorization: Bearer ${TOKEN}" \
            --header "Content-Type: application/json" \
            --data "{\"type\":\"CNAME\",\"proxied\":true,\"name\":\"${FULL_HOSTNAME}\",\"content\":\"${{ steps.tunnel.outputs.tunnel_id }}.cfargotunnel.com\"}")
          [ "$(echo "$RESPONSE" | jq -r '.success')" = "true" ] && echo "‚úÖ DNS created" || { echo "$RESPONSE" | jq '.errors'; exit 1; }

      - name: Start Cloudflare Tunnel
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
          sleep 10
          pgrep -x cloudflared > /dev/null && echo "‚úÖ Tunnel started" || { cat /tmp/tunnel.log; exit 1; }

      - name: Display VNC Connection Info
        if: steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë         üéâ VNC + BotXByte Extension is LIVE! üéâ          ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo "üåê URL: https://${{ steps.config.outputs.hostname }}/vnc.html"

      - name: Run Moti on Desktop
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export DISPLAY=:1 NO_AT_BRIDGE=1 SESSION_MANAGER="" DBUS_SESSION_BUS_ADDRESS=/dev/null
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ffmpeg \
            libavcodec-dev libavformat-dev libavdevice-dev libavutil-dev \
            libavfilter-dev libswscale-dev libswresample-dev pkg-config

          xfce4-terminal --maximize --title="Moti Process" \
            --command="bash -c 'export MOTI_JOB_CONFIG=\$(echo \"${{ inputs.base64_config }}\" | base64 -d) && pip install av --upgrade && pip install moti && moti; echo Done; read'" 2>/dev/null &
          sleep 5
          pgrep -f "xfce4-terminal" > /dev/null && echo "‚úÖ Moti started" || echo "‚ö†Ô∏è Terminal may not have launched"

      - name: Run Moti in Normal Terminal
        if: steps.config.outputs.vnc_enabled == 'false'
        timeout-minutes: 30
        run: |
          export MOTI_JOB_CONFIG=$(echo "${{ inputs.base64_config }}" | base64 -d)
          pip install moti && moti
          echo "‚úÖ Moti completed"

      - name: Keep VNC Session Alive
        if: steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          export DBUS_SESSION_BUS_ADDRESS=/dev/null
          EXTENSION_DIR="$HOME/real-botxbyte-extension"
          CHROME_PROFILE_DIR="$HOME/chrome-botxbyte-profile"

          # 355 min = 360 min timeout minus 5 min buffer for cleanup steps
          END_TIME=$((SECONDS + 21300))

          while [ $SECONDS -lt $END_TIME ]; do
            REMAINING=$((END_TIME - SECONDS))
            echo "‚è±Ô∏è  Remaining: $((REMAINING/3600))h $(((REMAINING%3600)/60))m"

            if ! pgrep -f "Xvnc.*:1" > /dev/null; then
              echo "‚ö†Ô∏è  VNC stopped ‚Äî restarting..."
              vncserver :1 -geometry 1920x1080 -depth 24 -rfbport $VNC_PORT
              sleep 3
              pgrep -f "Xvnc.*:1" > /dev/null && echo "‚úÖ VNC restarted" || { echo "‚ùå VNC restart failed"; exit 1; }
            fi

            if [ "${{ steps.config.outputs.cloudflare_enabled }}" = "true" ] && ! pgrep -x cloudflared > /dev/null; then
              echo "‚ö†Ô∏è  Tunnel stopped ‚Äî restarting..."
              cloudflared tunnel run --token ${{ steps.tunnel.outputs.tunnel_token }} > /tmp/tunnel.log 2>&1 &
              sleep 5
              pgrep -x cloudflared > /dev/null && echo "‚úÖ Tunnel restarted" || { cat /tmp/tunnel.log; exit 1; }
            fi

            if ! pgrep -f "server.py" > /dev/null; then
              echo "‚ö†Ô∏è  BotXByte server stopped ‚Äî restarting..."
              cd "$EXTENSION_DIR"
              export WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
              nohup python3 server.py > /tmp/botxbyte-server.log 2>&1 &
              sleep 3
              pgrep -f "server.py" > /dev/null && echo "‚úÖ Server restarted" || cat /tmp/botxbyte-server.log
            fi

            # If Chrome crashes, relaunch and re-load extension via CDP
            if ! pgrep -f "google-chrome" > /dev/null; then
              echo "‚ö†Ô∏è  Chrome stopped ‚Äî restarting with extension..."
              export DISPLAY=:1 NO_AT_BRIDGE=1 DBUS_SESSION_BUS_ADDRESS=/dev/null
              rm -rf "$EXTENSION_DIR/_metadata"

              google-chrome \
                --no-first-run --no-default-browser-check \
                --disable-gpu --no-sandbox --disable-dev-shm-usage \
                --enable-extensions \
                --user-data-dir="$CHROME_PROFILE_DIR" \
                --remote-debugging-port=9222 \
                --remote-allow-origins='*' \
                --new-window "chrome://extensions" \
                2>/tmp/chrome-stderr.log &
              sleep 12

              if pgrep -f "google-chrome" > /dev/null; then
                # Re-load extension via CDP (developer mode already on from previous session)
                python3 << INNEREOF
          import websocket, json, time, urllib.request, os

          EXTENSION_DIR = os.path.expanduser("~/real-botxbyte-extension")

          def cdp_http(path):
              try:
                  resp = urllib.request.urlopen(f"http://localhost:9222{path}", timeout=10)
                  return json.loads(resp.read())
              except:
                  return None

          def cdp_send(ws, method, params=None, msg_id=1):
              msg = {"id": msg_id, "method": method}
              if params: msg["params"] = params
              ws.send(json.dumps(msg))
              for _ in range(200):
                  try:
                      resp = json.loads(ws.recv())
                      if resp.get("id") == msg_id: return resp
                  except: break
              return {}

          targets = cdp_http("/json/list") or []
          ext_tab = next((t for t in targets if "chrome://extensions" in t.get("url","")), None)
          if ext_tab and ext_tab.get("webSocketDebuggerUrl"):
              ws = websocket.create_connection(ext_tab["webSocketDebuggerUrl"], timeout=15)
              time.sleep(2)
              # Enable dev mode
              cdp_send(ws, "Runtime.evaluate", {
                  "expression": """
                  (async()=>{
                      for(let i=0;i<20;i++){
                          const m=document.querySelector('extensions-manager');
                          if(m&&m.shadowRoot){
                              const t=m.shadowRoot.querySelector('extensions-toolbar');
                              if(t&&t.shadowRoot){
                                  const d=t.shadowRoot.querySelector('#devMode');
                                  if(d){if(!d.checked)d.click();return 'OK';}
                              }
                          }
                          await new Promise(r=>setTimeout(r,500));
                      }
                      return 'TIMEOUT';
                  })()
                  """, "awaitPromise": True
              }, msg_id=1)
              time.sleep(2)
              # Load extension
              r = cdp_send(ws, "Runtime.evaluate", {
                  "expression": f"""
                  (async()=>{{
                      return await new Promise(resolve=>{{
                          chrome.developerPrivate.loadUnpacked(
                              {{location:{json.dumps(EXTENSION_DIR)}}},
                              info=>{{
                                  if(chrome.runtime.lastError) resolve('ERROR:'+chrome.runtime.lastError.message);
                                  else resolve('OK:'+(info?info.id:'?'));
                              }}
                          );
                      }});
                  }})()
                  """, "awaitPromise": True
              }, msg_id=2)
              val = r.get("result",{}).get("result",{}).get("value","")
              print(f"Extension reload: {val}")
              ws.close()
          INNEREOF
                echo "‚úÖ Chrome restarted and extension reloaded"
              else
                echo "‚ö†Ô∏è Chrome failed to restart"
              fi
            fi

            sleep 30
          done
          echo "‚úÖ Session complete"

      - name: Cleanup Webshare
        if: always() && steps.config.outputs.webshare_enabled == 'true'
        run: |
          AUTH_ID="${{ steps.webshare.outputs.webshare_auth_id }}"
          [ -n "$AUTH_ID" ] && [ "$AUTH_ID" != "null" ] && \
            curl -s "https://proxy.webshare.io/api/v2/proxy/ipauthorization/${AUTH_ID}/" \
              -X DELETE -H "Authorization: Token ${{ steps.config.outputs.webshare_api_token }}" > /dev/null && \
            echo "‚úÖ Webshare IP deregistered"

      - name: Cleanup BotXByte
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          pkill -f "google-chrome" || true
          pkill -f "server.py" || true
          echo "‚úÖ Cleanup done"

      - name: Cleanup Cloudflare
        if: always() && steps.config.outputs.cloudflare_enabled == 'true'
        run: |
          pkill -x cloudflared || true
          sleep 2
          FULL_HOSTNAME="${{ steps.config.outputs.hostname }}"
          ACCT="${{ steps.config.outputs.cloudflare_account_id }}"
          ZONE="${{ steps.config.outputs.cloudflare_zone_id }}"
          TOKEN="${{ steps.config.outputs.cloudflare_api_token }}"
          TUNNEL_ID="${{ steps.tunnel.outputs.tunnel_id }}"
          USER_ID="${{ steps.config.outputs.user_id }}"
          WORKSPACE_ID="${{ steps.config.outputs.workspace_id }}"
          BROWSER_PROFILE_ID="${{ steps.config.outputs.browser_profile_id }}"

          if [ -n "$FULL_HOSTNAME" ] && [ "$FULL_HOSTNAME" != "null" ]; then
            DEL_URL="http://129.212.196.173/ai-management-service/api/v1/cloudflare-tunnel-info/delete/?tunnel_url=https://${FULL_HOSTNAME}"
            [ -n "$BROWSER_PROFILE_ID" ] && [ "$BROWSER_PROFILE_ID" != "null" ] && \
              DEL_URL="${DEL_URL}&browser_profile_id=${BROWSER_PROFILE_ID}"
            curl -s "$DEL_URL" -X DELETE -H "user-id: ${USER_ID}" -H "workspace-id: ${WORKSPACE_ID}" > /dev/null

            DNS_ID=$(curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records?name=${FULL_HOSTNAME}" \
              --header "Authorization: Bearer ${TOKEN}" | jq -r '.result[0].id // empty')
            [ -n "$DNS_ID" ] && curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/zones/${ZONE}/dns_records/${DNS_ID}" \
              --request DELETE --header "Authorization: Bearer ${TOKEN}" | \
              jq -r 'if .success then "‚úÖ DNS deleted" else "‚ö†Ô∏è DNS delete failed" end'
          fi

          [ -n "$TUNNEL_ID" ] && [ "$TUNNEL_ID" != "null" ] && \
            curl -s -A "Mozilla/5.0" \
              "https://api.cloudflare.com/client/v4/accounts/${ACCT}/cfd_tunnel/${TUNNEL_ID}" \
              --request DELETE --header "Authorization: Bearer ${TOKEN}" | \
            jq -r 'if .success then "‚úÖ Tunnel deleted" else "‚ö†Ô∏è Tunnel delete failed" end'

      - name: Cleanup VNC
        if: always() && steps.config.outputs.vnc_enabled == 'true'
        run: |
          export PATH=$PATH:/opt/TurboVNC/bin
          vncserver -kill :1 || true
          echo "‚úÖ VNC cleaned up"
